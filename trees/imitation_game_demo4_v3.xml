<?xml version="1.0"?>
<root main_tree_to_execute="BehaviorTree">
    <!-- ////////// -->
    <BehaviorTree ID="ASRWaitSpeakingStarts">
        <Action ID="WaitSpeakingStartsAction" action="/strawberry_ros_speech_detection_node/wait_starts_speaking" mics_id="{mics_id}" serialized_feedback="feedback" serialized_result="result" state="state" timeout="{start_timeout}"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="ASRWaitSpeakingStops">
        <Action ID="WaitSpeakingStopsAction" action="/strawberry_ros_speech_detection_node/wait_stops_speaking" hard_timeout="{total_speaking_timeout}" mics_id="{mics_id}" serialized_feedback="feedback" serialized_result="result" soft_timeout="{in_between_timeout}" state="state"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="BehaviorTree">
        <Fallback>
            <Sequence>
                <Sequence>
                    <SubTree ID="UnityProjectorShowImage" __shared_blackboard="false" image_file="/home/haru/haru_interactions_ws/src/imitation_game/pictures/imitation.png"/>
                    <RetryUntilSuccessful num_attempts="-1">
                        <Sequence>
                            <SetBlackboard output_key="people" value=""/>
                            <SetBlackboard output_key="people_header" value=""/>
                            <Action ID="StrawberryMonitorPeople" consume_msgs="1" queue_size="1" serialized_output="people_vector" topic="/strawberry/people"/>
                            <WaitSeconds duration="1"/>
                            <Action ID="ConvertMessageField" field="/people/0" input="{people_vector}" output="check_empty"/>
                            <Action ID="ConvertMessageField" field="/people" input="{people_vector}" output="people"/>
                            <Action ID="ConvertMessageField" field="/header" input="{people_vector}" output="people_header"/>
                        </Sequence>
                    </RetryUntilSuccessful>
                    <SubTree ID="HaruGetClosestPerson" closest_person="closest_person" people="{people}" people_header="{people_header}"/>
                </Sequence>
                <Sequence>
                    <SubTree ID="HaruSpeaksTTSAndWait" feedback="tts_feed" phrases="&lt;routine&gt;wave&lt;/routine&gt;&lt;spurt audio='g0001_408'&gt;Heeeeeeey!&lt;/spurt&gt;&#10;&lt;break type=&quot;3&quot; time=&quot;1.5&quot;/&gt; My name is Haru" result="tts_result"/>
                    <SubTree ID="HaruExecuteRoutineAndWait" feedback="routine_feed" result="routine_result" routines="929"/>
                    <SubTree ID="HaruSpeaksTTSAndWait" feedback="tts_feed" phrases="&lt;usel genre='question'&gt; Would you like to play the Imitation Game with me?&lt;/usel&gt;" result="tts_result"/>
                    <SubTree ID="StrawberryEnableASR"/>
                    <WaitSeconds duration="1"/>
                    <RetryUntilSuccessful num_attempts="-1">
                        <Parallel failure_threshold="1" success_threshold="2">
                            <Fallback>
                                <ForceFailure>
                                    <WaitMilliseconds duration="250"/>
                                </ForceFailure>
                                <SubTree ID="StrawberryGetASR" asr_result="asr" asr_result_conf="asrC" asr_result_msg="asrM"/>
                            </Fallback>
                            <Fallback>
                                <SubTree ID="IsHaruRoutinePlaying"/>
                                <SubTree ID="HaruExecuteRoutine" routines="3"/>
                            </Fallback>
                        </Parallel>
                    </RetryUntilSuccessful>
                    <Action ID="InfoLog" message="${asr}"/>
                    <Sequence>
                        <SubTree ID="HaruNlpYesNo" answer="answer" transcription="${asr}"/>
                        <Action ID="InfoLog" message="${answer}"/>
                        <CompareStrings comparison_op="==" first="${answer}" second="Yes"/>
                    </Sequence>
                    <SubTree ID="StrawberryDisableASR"/>
                </Sequence>
                <Sequence>
                    <SubTree ID="HaruExecuteRoutine" routines="7"/>
                    <SubTree ID="HaruSpeaksTTSAndWait" feedback="tts_feed" phrases="&lt;usel genre=&quot;highnrg&quot;&gt;Awesome!&lt;/usel&gt; Let me explain how this game works.&lt;break type=&quot;3&quot; time=&quot;1.5&quot;/&gt; &lt;voice emotion='calm'&gt;&lt;spurt audio='g0001_006'&gt;clear throat&lt;/spurt&gt;I am going to perform an action, and then you try to copy me. &lt;/voice&gt; " result="tts_result"/>
                    <SubTree ID="HaruExecuteRoutine" routines="7"/>
                    <SubTree ID="HaruSpeaksTTSAndWait" feedback="tts_feed" phrases="&lt;break type=&quot;3&quot; time=&quot;1.0&quot;/&gt;Got it?" result="tts_result"/>
                </Sequence>
                <WhileSuccess>
                    <Sequence>
                        <Sequence>
                            <WaitSeconds duration="5"/>
                            <SubTree ID="HaruSpeaksTTSAndWait" feedback="tts_feed" phrases="Get ready. Here I go!" result="tts_result"/>
                            <SubTree ID="UnityProjectorShowImage" __shared_blackboard="false" image_file="/home/haru/haru_interactions_ws/src/imitation_game/pictures/myTurn.png"/>
                        </Sequence>
                        <Sequence>
                            <RandomSequenceValue delimiter=";" output="first_routine" sequence="610;826;690;952;609;600"/>
                            <SubTree ID="HaruExecuteRoutineAndWait" feedback="routine_feed" result="routine_result" routines="${first_routine}"/>
                            <WaitSeconds duration="1"/>
                            <SubTree ID="HaruSpeaksTTSAndWait" feedback="tts_feed" phrases="&lt;usel genre=&quot;highnrg&quot;&gt;OK. Now it is your turn&lt;/usel&gt;&lt;break type=&quot;3&quot; time=&quot;1.0&quot; /&gt; Let us see your best Haru impression, you have 5 seconds." result="tts_result"/>
                            <Action ID="PublishStdString" data="file:///home/haru/haru_interactions_ws/src/imitation_game/pictures/imitation_pages/timer_imitate/show_camera.html" latch="0" name="Set URL of page to show" queue_size="1" topic="/unity_projector/browser/set"/>
                            <Action ID="PublishStdBool" data="true" latch="0" name="Show web browser" queue_size="1" topic="/unity_projector/browser/show"/>
                            <Sequence>
                                <RandomSequenceValue delimiter=";" output="listening_feedback_routine" sequence="129;131;528"/>
                                <SubTree ID="HaruExecuteRoutine" routines="${listening_feedback_routine}"/>
                                <WaitSeconds duration="3"/>
                                <ForceSuccess>
                                    <SubTree ID="HaruTakePhoto" image_name="user_face" path="/home/haru/haru_interactions_ws/src/imitation_game/pictures/imitation_pages/gestures_screenshot/images/"/>
                                </ForceSuccess>
                                <RetryUntilSuccessful num_attempts="-1">
                                    <Sequence>
                                        <Action ID="HaruMonitorBrowser" consume_msgs="0" queue_size="1" serialized_output="json" topic="/idmind_tabletop/browser_action"/>
                                        <Action ID="ConvertMessageField" field="/data" input="{json}" output="browser_status"/>
                                        <CompareStrings comparison_op="==" first="{browser_status}" second="done"/>
                                    </Sequence>
                                </RetryUntilSuccessful>
                                <Sequence>
                                    <ConcatenateStrings first="file:///home/haru/haru_interactions_ws/src/imitation_game/pictures/imitation_pages/gestures_screenshot/gestures_screenshot.html?routine=" output="url" second="${first_routine}"/>
                                    <Action ID="PublishStdString" data="${url}" latch="0" queue_size="1" topic="/unity_projector/browser/set"/>
                                    <WaitSeconds duration="5"/>
                                </Sequence>
                            </Sequence>
                        </Sequence>
                        <Sequence>
                            <RandomSequenceValue delimiter=";" output="second_routine" sequence="1042;801;543;606"/>
                            <SubTree ID="HaruSpeaksTTSAndWait" feedback="tts_feed" phrases="&lt;routine&gt;surprise&lt;/routine&gt;&lt;spurt audio='g0001_354 '&gt;Uh-huh&lt;/spurt&gt; that’s pretty good. &lt;break type=&quot;3&quot; time=&quot;1.5&quot; /&gt;&lt;usel genre='question'&gt;But can you do this?&lt;/usel&gt;;&lt;routine&gt;surprise&lt;/routine&gt;&lt;usel genre=&quot;highnrg&quot;&gt;That is not bad! &lt;break type=&quot;3&quot; time=&quot;1.5&quot; /&gt;&lt;/usel&gt;&lt;usel genre='question'&gt;But what if I did this instead?&lt;/usel&gt;;&lt;routine&gt;cheeky&lt;/routine&gt;&lt;usel genre=&quot;highnrg&quot;&gt;&lt;spurt audio='g0001_002'&gt;tut tut&lt;/spurt&gt;Not bad, not bad.&lt;break type=&quot;3&quot; time=&quot;1.0&quot; /&gt; But let us see how good you really are.&lt;/usel&gt; " result="tts_result"/>
                            <SubTree ID="UnityProjectorShowImage" __shared_blackboard="false" image_file="/home/haru/haru_interactions_ws/src/imitation_game/pictures/myTurn.png"/>
                            <Action ID="PublishStdBool" data="false" latch="0" queue_size="1" topic="/unity_projector/browser/show"/>
                            <SubTree ID="HaruExecuteRoutineAndWait" feedback="routine_feed" result="routine_result" routines="${second_routine}"/>
                        </Sequence>
                        <Sequence>
                            <SubTree ID="HaruSpeaksTTSAndWait" feedback="tts_feed" phrases="&lt;usel genre=&quot;cheeky&quot;&gt;I bet you did not think I could do that. &lt;break type=&quot;3&quot; time=&quot;1.5&quot; /&gt;Let us see if you can match it&lt;/usel&gt;;&lt;usel genre=&quot;cheeky&quot;&gt;You were not expecting that, were you? &lt;break type=&quot;3&quot; time=&quot;1.5&quot; /&gt;Your turn!&lt;/usel&gt;;&lt;voice emotion='happy'&gt; Pretty impressive, right?&lt;break type=&quot;3&quot; time=&quot;1.5&quot; /&gt;Most robots can not do that!&lt;/voice&gt;.&lt;break type=&quot;3&quot; time=&quot;1.0&quot; /&gt; &lt;usel genre='question'&gt;Can you?&lt;/usel&gt;;&lt;usel genre=&quot;cheeky&quot;&gt;&lt;spurt audio='g0001_052'&gt;gasp&lt;/spurt&gt;Wow. &lt;break type=&quot;3&quot; time=&quot;1.0&quot; /&gt;Where did that come from?&lt;break type=&quot;3&quot; time=&quot;1.0&quot; /&gt; I surprise myself sometimes. &lt;break type=&quot;3&quot; time=&quot;1.5&quot; /&gt;Can you do that?&lt;/usel&gt;;&lt;usel genre=&quot;highnrg&quot;&gt;That took me a long time to learn,&lt;break type=&quot;3&quot; time=&quot;0.5&quot; /&gt; but my hard work paid off&lt;break type=&quot;3&quot; time=&quot;1.5&quot; /&gt;Now you try!&lt;/usel&gt;" result="tts_result"/>
                            <Action ID="PublishStdString" data="file:///home/haru/haru_interactions_ws/src/imitation_game/pictures/imitation_pages/timer_imitate/show_camera.html" latch="0" queue_size="1" topic="/unity_projector/browser/set"/>
                            <Action ID="PublishStdBool" data="true" latch="0" queue_size="1" topic="/unity_projector/browser/show"/>
                            <Sequence>
                                <RandomSequenceValue delimiter=";" output="listening_feedback_routine" sequence="129;131;528"/>
                                <SubTree ID="HaruExecuteRoutine" routines="${listening_feedback_routine}"/>
                                <WaitSeconds duration="3"/>
                                <ForceSuccess>
                                    <SubTree ID="HaruTakePhoto" image_name="user_face" path="/home/haru/haru_interactions_ws/src/imitation_game/pictures/imitation_pages/gestures_screenshot/images/"/>
                                </ForceSuccess>
                                <RetryUntilSuccessful num_attempts="-1">
                                    <Sequence>
                                        <Action ID="HaruMonitorBrowser" consume_msgs="0" queue_size="1" serialized_output="json" topic="/idmind_tabletop/browser_action"/>
                                        <Action ID="ConvertMessageField" field="/data" input="{json}" output="browser_status"/>
                                        <CompareStrings comparison_op="==" first="{browser_status}" second="done"/>
                                    </Sequence>
                                </RetryUntilSuccessful>
                                <Sequence>
                                    <ConcatenateStrings first="file:///home/haru/haru_interactions_ws/src/imitation_game/pictures/imitation_pages/gestures_screenshot/gestures_screenshot.html?routine=" output="url" second="${second_routine}"/>
                                    <Action ID="PublishStdString" data="${url}" latch="0" queue_size="1" topic="/unity_projector/browser/set"/>
                                    <WaitSeconds duration="5"/>
                                </Sequence>
                            </Sequence>
                            <SubTree ID="HaruExecuteRoutine" routines="613"/>
                            <Action ID="PublishStdBool" data="false" latch="0" queue_size="1" topic="/unity_projector/browser/show"/>
                            <SubTree ID="HaruSpeaksTTSAndWait" feedback="tts_feed" phrases="&lt;usel genre=&quot;highnrg&quot;&gt;Not bad, not bad. &lt;break type=&quot;3&quot; time=&quot;1.0&quot; /&gt;Let us switch things up.  &lt;break type=&quot;3&quot; time=&quot;0.5&quot; /&gt;You do something, and I will try and imitate you.&lt;break type=&quot;3&quot; time=&quot;1.0&quot; /&gt; Ready? &lt;break type=&quot;3&quot; time=&quot;1.0&quot; /&gt;Go!&lt;/usel&gt;" result="tts_result"/>
                            <Action ID="PublishStdString" data="file:///home/haru/haru_interactions_ws/src/imitation_game/pictures/imitation_pages/timer_imitate/show_camera.html" latch="0" queue_size="1" topic="/unity_projector/browser/set"/>
                            <Action ID="PublishStdBool" data="true" latch="0" queue_size="1" topic="/unity_projector/browser/show"/>
                            <Sequence>
                                <RandomSequenceValue delimiter=";" output="listening_feedback_routine" sequence="129;131;528"/>
                                <SubTree ID="HaruExecuteRoutine" routines="${listening_feedback_routine}"/>
                                <WaitSeconds duration="3"/>
                                <ForceSuccess>
                                    <SubTree ID="HaruTakePhoto" image_name="user_face" path="/home/haru/haru_interactions_ws/src/imitation_game/pictures/imitation_pages/gestures_screenshot/images/"/>
                                </ForceSuccess>
                                <RetryUntilSuccessful num_attempts="-1">
                                    <Sequence>
                                        <Action ID="HaruMonitorBrowser" consume_msgs="0" queue_size="1" serialized_output="json" topic="/idmind_tabletop/browser_action"/>
                                        <Action ID="ConvertMessageField" field="/data" input="{json}" output="browser_status"/>
                                        <CompareStrings comparison_op="==" first="{browser_status}" second="done"/>
                                    </Sequence>
                                </RetryUntilSuccessful>
                            </Sequence>
                        </Sequence>
                        <Sequence>
                            <SubTree ID="HaruExecuteRoutineAndWait" feedback="routine_feed" result="routine_result" routines="102"/>
                            <Action ID="PublishStdBool" data="false" latch="0" queue_size="1" topic="/unity_projector/browser/show"/>
                            <SubTree ID="HaruSpeakExpressive" text="Okay. Here is my impression of you. "/>
                            <SubTree ID="UnityProjectorShowImage" __shared_blackboard="false" image_file="/home/haru/haru_interactions_ws/src/imitation_game/pictures/myTurn.png"/>
                            <RandomSequenceValue delimiter=";" output="third_routine" sequence="1034;1006;613;200;620"/>
                            <SubTree ID="HaruExecuteRoutineAndWait" feedback="routine_feed" result="routine_result" routines="${third_routine}"/>
                            <ConcatenateStrings first="file:///home/haru/haru_interactions_ws/src/imitation_game/pictures/imitation_pages/gestures_screenshot/gestures_screenshot.html?routine=" output="url" second="${third_routine}"/>
                            <Action ID="PublishStdBool" data="true" latch="0" queue_size="1" topic="/unity_projector/browser/show"/>
                            <Action ID="PublishStdString" data="${url}" latch="0" queue_size="1" topic="/unity_projector/browser/set"/>
                            <SubTree ID="HaruSpeaksTTSAndWait" feedback="tts_feed" phrases="&lt;usel genre=&quot;happy&quot;&gt;What did you think? &lt;break type=&quot;3&quot; time=&quot;0.5&quot; /&gt;Pretty good, right?&lt;/usel&gt;;&lt;spurt audio='g0001_038'&gt;oh negative&lt;/spurt&gt;&lt;usel genre=&quot;sad&quot;&gt;OK. &lt;break type=&quot;3&quot; time=&quot;0.5&quot; /&gt;That was not my best work.&lt;/usel&gt; &lt;break type=&quot;3&quot; time=&quot;1.0&quot; /&gt;&lt;usel genre=&quot;cheeky&quot;&gt;But you were not really being fair!&lt;/usel&gt;&#10;;&lt;usel genre=&quot;highnrg&quot;&gt;Nailed it! &lt;/usel&gt; &lt;break type=&quot;3&quot; time=&quot;1.0&quot; /&gt;&lt;usel genre=&quot;whiny&quot;&gt;But now I am dizzy.&lt;/usel&gt; &lt;break type=&quot;3&quot; time=&quot;1.0&quot; /&gt;&lt;usel genre=&quot;serious&quot;&gt;Anyway...&lt;/usel&gt;;&lt;usel genre=&quot;highnrg&quot;&gt;That’s you. &lt;break type=&quot;3&quot; time=&quot;1.0&quot; /&gt;That’s what you look like to me.&lt;/usel&gt;;&lt;usel genre=&quot;highnrg&quot;&gt;You should see your face.!&lt;/usel&gt;&lt;spurt audio='g0001_050'&gt;ha ha (sarcastic)&lt;/spurt&gt;&lt;break type=&quot;3&quot; time=&quot;1.5&quot; /&gt; &lt;usel genre=&quot;cheeky&quot;&gt;You are stunned at how well I captured your essence.&lt;/usel&gt;" result="tts_result"/>
                            <SubTree ID="HaruExecuteRoutine" routines="616"/>
                        </Sequence>
                        <Sequence>
                            <WaitSeconds duration="2"/>
                            <SubTree ID="UnityProjectorShowImage" __shared_blackboard="false" image_file="/home/haru/haru_interactions_ws/src/imitation_game/pictures/ending_imitation.png"/>
                            <SubTree ID="HaruSpeaksTTSAndWait" feedback="tts_feed" phrases="&lt;routine&gt;yes&lt;/routine&gt;&lt;usel genre=&quot;highnrg&quot;&gt;I think I did a great job. &lt;break type=&quot;3&quot; time=&quot;1.0&quot; /&gt;I win! &lt;/usel&gt;&lt;spurt audio='g0001_036'&gt;yay&lt;/spurt&gt;&lt;break type=&quot;3&quot; time=&quot;1.0&quot; /&gt;&lt;usel genre=&quot;highnrg&quot;&gt;But you put in a good effort.&lt;/usel&gt; " result="tts_result"/>
                            <SubTree ID="HaruExecuteRoutine" routines="627"/>
                            <Fallback>
                                <Sequence>
                                    <WaitSeconds duration="2"/>
                                    <SubTree ID="HaruSpeaksTTSAndWait" feedback="tts_feed" phrases="Do you want to play again?" result="tts_result"/>
                                    <SubTree ID="StrawberryEnableASR"/>
                                    <RetryUntilSuccessful num_attempts="-1">
                                        <Parallel failure_threshold="1" success_threshold="2">
                                            <Fallback>
                                                <ForceFailure>
                                                    <WaitMilliseconds duration="250"/>
                                                </ForceFailure>
                                                <SubTree ID="StrawberryGetASR" asr_result="asr" asr_result_conf="asrC" asr_result_msg="asrM"/>
                                            </Fallback>
                                            <Fallback>
                                                <SubTree ID="IsHaruRoutinePlaying"/>
                                                <SubTree ID="HaruExecuteRoutine" routines="3"/>
                                            </Fallback>
                                        </Parallel>
                                    </RetryUntilSuccessful>
                                    <Sequence>
                                        <SubTree ID="HaruNlpYesNo" answer="transcript" transcription="${asr}"/>
                                        <Action ID="InfoLog" message="${transcript}"/>
                                        <CompareStrings comparison_op="==" first="${transcript}" second="Yes"/>
                                    </Sequence>
                                    <SubTree ID="StrawberryDisableASR"/>
                                </Sequence>
                                <ForceFailure>
                                    <Sequence>
                                        <SubTree ID="HaruSpeakExpressive" text="If you want a rematch, come back anytime."/>
                                        <SubTree ID="HaruExecuteRoutineAndWait" feedback="routine_feed" result="routine_result" routines="612"/>
                                    </Sequence>
                                </ForceFailure>
                            </Fallback>
                        </Sequence>
                    </Sequence>
                </WhileSuccess>
            </Sequence>
            <Sequence>
                <SubTree ID="HaruProjectorStop"/>
                <SubTree ID="HaruSpeaksTTSAndWait" feedback="tts_feed" phrases="&lt;routine&gt;wave&lt;/routine&gt;Bye bye" result="tts_result"/>
            </Sequence>
        </Fallback>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="ExecuteTreeAndWait">
        <Action ID="ExecuteRemoteTree" action="/behavior_tree/load_tree_action" state="state" tree_file.data="{tree_file}"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="FindDialogEntity">
        <Sequence>
            <SetBlackboard output_key="entity_found" value="0"/>
            <Decorator ID="ForEachLoop" break_on_child_failure="false" input="{entities_list}" output_element="entity_type" output_index="">
                <Sequence>
                    <Action ID="ConvertMessageField" field="/display_name" input="{entity_type}" output="entity_type_name"/>
                    <FindSubstrings input="{entity_type_name}" substrings="{entities_name}"/>
                    <SetBlackboard output_key="entity_found" value="1"/>
                    <Action ID="ConvertMessageField" field="/entities" input="{entity_type}" output="entity_elements"/>
                    <Action ID="ConvertMessageField" field="/display_name" input="{entity_type}" output="entity_name"/>
                </Sequence>
            </Decorator>
            <CheckBool input="{entity_found}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruAudioMusicPlayAndWait">
        <Action ID="HaruCommandAudioMusicAction" action="/idmind_tabletop/action_audio_music" end_time="{end_time}" fade="{fade_enable}" fade_duration="{fade_duration}" fade_out="{fade_out_enable}" fade_out_duration="{fade_out_duration}" file="{music_file}" loop="{loop}" serialized_feedback="feedback" serialized_result="result" start_time="{start_time}" state="state" volume="{volume}"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruAudioPlay">
        <Action ID="HaruCommandAudio" channel="{channel_id}" command="0" end_time="{end_time}" fade_in="{fade_enable}" fade_in_duration="{fade_duration}" fade_out="{fade_out_enable}" fade_out_duration="{fade_out_duration}" file="{audio_file}" latch="0" loop="{loop}" queue_size="1" start_time="{start_time}" topic="/idmind_tabletop/cmd_audio" volume="{volume}"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruAudioSpeechPlayAndWait">
        <Action ID="HaruCommandAudioSpeechAction" action="/idmind_tabletop/action_audio_speech" end_time="{end_time}" fade="{fade_enable}" fade_duration="{fade_duration}" fade_out="{fade_out_enable}" fade_out_duration="{fade_out_duration}" file="{speech_file}" loop="{loop}" serialized_feedback="feedback" serialized_result="result" start_time="{start_time}" state="state" volume="{volume}"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruAudioStop">
        <Action ID="HaruCommandAudio" channel="{channel_id}" command="1" end_time="0" fade_in="0" fade_in_duration="0" fade_out="{fade_out_enable}" fade_out_duration="{fade_out_duration}" file="" latch="0" loop="0" queue_size="1" start_time="0" topic="/idmind_tabletop/cmd_audio" volume="1"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruChangeAudioChannelVolume">
        <Sequence>
            <Action ID="HaruCommandConfigureAudioOnline" channel_id="${channel_id}" do_fade="${do_fade}" fade_duration="${fade_duration}" serialized_output="output" service="/idmind_tabletop/change_audio_channel_volume" volume="${volume}"/>
            <Action ID="ConvertMessageField" field="/info_msg" input="${output}" output="info_msg"/>
            <Action ID="ConvertMessageField" field="/success" input="${output}" output="success"/>
            <Fallback>
                <Sequence>
                    <CheckBool input="${success}"/>
                    <Action ID="InfoLog" message="${info_msg}"/>
                </Sequence>
                <ForceFailure>
                    <Action ID="ErrorLog" message="${info_msg}"/>
                </ForceFailure>
            </Fallback>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruCheckTelegramUserByID">
        <Sequence>
            <Action ID="HaruCommandTelegramCheckUserByID" serialized_output="output" service="/telegram_bot/check_user_by_id" user_id="{user_id}"/>
            <Action ID="ConvertMessageField" field="/success" input="{output}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruCheckTelegramUserByName">
        <Sequence>
            <Action ID="HaruCommandTelegramCheckUserByName" serialized_output="output" service="/telegram_bot/check_user_by_name" user_name="{user_name}"/>
            <Action ID="ConvertMessageField" field="/success" input="{output}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruCommandJoints">
        <Fallback>
            <Sequence>
                <CompareStrings comparison_op="==" first="${motor}" second="base"/>
                <Action ID="HaruCommandMotor" disable_eyes_roll_sync="0" latch="0" motor="0" play_time="${time}" position="${pos}" queue_size="1" relative="${rel}" topic="/idmind_tabletop/cmd_base_pos"/>
            </Sequence>
            <Sequence>
                <CompareStrings comparison_op="==" first="${motor}" second="head"/>
                <Action ID="HaruCommandMotor" disable_eyes_roll_sync="0" latch="0" motor="0" play_time="${time}" position="${pos}" queue_size="1" relative="${rel}" topic="/idmind_tabletop/cmd_head_pos"/>
            </Sequence>
            <Sequence>
                <CompareStrings comparison_op="==" first="${motor}" second="neck"/>
                <Action ID="HaruCommandMotor" disable_eyes_roll_sync="0" latch="0" motor="0" play_time="${time}" position="${pos}" queue_size="1" relative="${rel}" topic="/idmind_tabletop/cmd_neck_pos"/>
            </Sequence>
            <Sequence>
                <CompareStrings comparison_op="==" first="${motor}" second="roll"/>
                <Action ID="HaruCommandMotor" disable_eyes_roll_sync="0" latch="0" motor="0" play_time="${time}" position="${pos}" queue_size="1" relative="${rel}" topic="/idmind_tabletop/cmd_eyes_roll_pos"/>
            </Sequence>
            <Sequence>
                <CompareStrings comparison_op="==" first="${motor}" second="stroke"/>
                <Action ID="HaruCommandMotor" disable_eyes_roll_sync="0" latch="0" motor="0" play_time="${time}" position="${pos}" queue_size="1" relative="false" topic="/idmind_tabletop/cmd_eyes_stroke_pos"/>
            </Sequence>
        </Fallback>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruExecuteMultiRoutine">
        <Action ID="HaruCommandMultiRoutine" routine_command="${command}" service="/idmind_tabletop/execute_multi_routine"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruExecuteMultiRoutineAndWait">
        <Action ID="HaruCommandMultiRoutineAction" action="/idmind_tabletop/action_multi_routine" routine_command="{command}" serialized_feedback="feedback" serialized_result="result" state="state"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruExecuteRoutine">
        <Sequence>
            <RandomSequenceValue delimiter=";" name="RandomRoutine" output="routine_rnd" sequence="${routines}"/>
            <ConcatenateStrings first="Playing routine: " output="message" second="${routine_rnd}"/>
            <Action ID="InfoLog" message="${message}"/>
            <Action ID="HaruCommandRoutine" routine="${routine_rnd}" service="/idmind_tabletop/execute_routine"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruExecuteRoutineAndWait">
        <Sequence>
            <RandomSequenceValue delimiter=";" output="routine" sequence="{routines}"/>
            <Action ID="HaruCommandRoutineAction" action="/idmind_tabletop/action_routine" id="{routine}" serialized_feedback="feedback" serialized_result="result" state="state"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruGetClosestPerson">
        <Sequence>
            <SetBlackboard output_key="min_distance" value="99"/>
            <SetBlackboard output_key="found_person" value="false"/>
            <SetBlackboard output_key="closest_person" value=""/>
            <Action ID="ConvertMessageField" field="/frame_id" input="${people_header}" output="people_frame_id"/>
            <Decorator ID="ForEachLoop" break_on_child_failure="false" input="${people}" output_element="person_element" output_index="">
                <Sequence>
                    <SubTree ID="HaruGetPersonDistance" distance="new_distance" frame_id="{people_frame_id}" person="{person_element}"/>
                    <CompareNumbers comparison_op="&lt;" first="${new_distance}" second="${min_distance}"/>
                    <SetBlackboard output_key="min_distance" value="${new_distance}"/>
                    <SetBlackboard output_key="closest_person" value="${person_element}"/>
                    <SetBlackboard output_key="found_person" value="true"/>
                    <Action ID="InfoLog" message="FOUND PERSON!"/>
                </Sequence>
            </Decorator>
            <CheckBool input="${found_person}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruGetClosestPersonFacingRobot">
        <Sequence>
            <SetBlackboard output_key="min_distance" value="99"/>
            <SetBlackboard output_key="found_person" value="false"/>
            <SetBlackboard output_key="closest_person" value=""/>
            <SetBlackboard output_key="result_angle" value="0.0"/>
            <Action ID="ConvertMessageField" field="/frame_id" input="${people_header}" output="people_frame_id"/>
            <Decorator ID="ForEachLoop" break_on_child_failure="false" input="${people}" output_element="person_element" output_index="">
                <Sequence>
                    <SubTree ID="HaruGetPersonHeadAngles" frame_id="{people_frame_id}" person="{person_element}" pitch="p" roll="r" yaw="y"/>
                    <Fallback>
                        <Sequence>
                            <CompareStrings comparison_op="==" first="${selected_angle}" second="roll"/>
                            <SetBlackboard output_key="result_angle" value="${r}"/>
                        </Sequence>
                        <Sequence>
                            <CompareStrings comparison_op="==" first="${selected_angle}" second="pitch"/>
                            <SetBlackboard output_key="result_angle" value="${p}"/>
                        </Sequence>
                        <SetBlackboard output_key="result_angle" value="${y}"/>
                    </Fallback>
                    <CompareNumbers comparison_op="&gt;" first="${result_angle}" second="${min_angle}"/>
                    <CompareStrings comparison_op="&lt;" first="${result_angle}" second="${max_angle}"/>
                    <SubTree ID="HaruGetPersonDistance" distance="new_distance" frame_id="{people_frame_id}" person="{person_element}"/>
                    <CompareNumbers comparison_op="&lt;" first="${new_distance}" second="${min_distance}"/>
                    <SetBlackboard output_key="min_distance" value="${new_distance}"/>
                    <SetBlackboard output_key="closest_person" value="${person_element}"/>
                    <SetBlackboard output_key="found_person" value="true"/>
                    <Action ID="InfoLog" message="FOUND PERSON!"/>
                </Sequence>
            </Decorator>
            <CheckBool input="${found_person}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruGetFastestTF">
        <Sequence>
            <Action ID="HaruMonitorFastestTF" consume_msgs="0" queue_size="1" serialized_output="output" topic="/strawberry/fastest_tf"/>
            <Action ID="ConvertMessageField" field="/tf_frame_id" input="${output}" output="tf_frame_id"/>
            <Action ID="ConvertMessageField" field="/speed" input="${output}" output="speed"/>
            <Action ID="ConvertMessageField" field="/person_id" input="${output}" output="person_id"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruGetNewTelegramMsg">
        <Sequence>
            <Action ID="HaruCommandTelegramGetNewMsg" serialized_output="output" service="/telegram_bot/get_new_msg"/>
            <Action ID="ConvertMessageField" field="/total_msgs_num" input="${output}" output="num_msgs"/>
            <Action ID="ConvertMessageField" field="/unread_msgs_num" input="${output}" output="num_unread_msgs"/>
            <Action ID="ConvertMessageField" field="/msg/msg_id" input="${output}" output="msg_id"/>
            <Action ID="ConvertMessageField" field="/msg/msg_timestamp_sec" input="${output}" output="msg_timestamp"/>
            <Action ID="ConvertMessageField" field="/msg/chat_id" input="${output}" output="user_chat_id"/>
            <Action ID="ConvertMessageField" field="/msg/user_name" input="${output}" output="user_name"/>
            <Action ID="ConvertMessageField" field="/msg/user_firstname" input="${output}" output="user_firstname"/>
            <Action ID="ConvertMessageField" field="/msg/type" input="${output}" output="msg_type"/>
            <Action ID="ConvertMessageField" field="/msg/text" input="${output}" output="msg_text"/>
            <Action ID="ConvertMessageField" field="/msg/emoji" input="${output}" output="msg_emoji"/>
            <Action ID="ConvertMessageField" field="/msg/emoji_routine_id" input="${output}" output="msg_emoji_routine_id"/>
            <Action ID="ConvertMessageField" field="/msg/harumoji" input="${output}" output="msg_harumoji"/>
            <Action ID="ConvertMessageField" field="/msg/harumoji_routine_id" input="${output}" output="msg_harumoji_routine_id"/>
            <Action ID="ConvertMessageField" field="/msg/audio_file_path" input="${output}" output="msg_audio_file_path"/>
            <Action ID="ConvertMessageField" field="/msg/is_audio_transcribed" input="${output}" output="msg_is_audio_transcribed"/>
            <Action ID="ConvertMessageField" field="/msg/audio_transcription" input="${output}" output="msg_audio_transcription"/>
            <Action ID="ConvertMessageField" field="/msg/photo_file_path" input="${output}" output="msg_photo_file_path"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruGetPersonDistance">
        <Sequence>
            <SetBlackboard output_key="haru_tf" value="/idmind_tabletop/base"/>
            <Action ID="ConvertMessageField" field="/id" input="${person}" output="person_id"/>
            <ConcatenateStrings first="${frame_id}" output="tf_prestart" second="/skeletons/"/>
            <ConcatenateStrings first="${tf_prestart}" output="tf_start" second="${person_id}"/>
            <ConcatenateStrings first="${tf_start}" output="person_tf" second="/spine_mid"/>
            <Action ID="LookupTransform" output="transform" source_frame="${haru_tf}" target_frame="${person_tf}" use_last_available="true"/>
            <Action ID="GetTransformHorizontalDistance" input="${transform}" output="distance"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruGetPersonHeadAngles">
        <Sequence>
            <SetBlackboard output_key="haru_tf" value="/idmind_tabletop/base"/>
            <Action ID="ConvertMessageField" field="/id" input="${person}" output="person_id"/>
            <ConcatenateStrings first="${frame_id}" output="tf_prestart" second="/skeletons/"/>
            <ConcatenateStrings first="${tf_prestart}" output="tf_start" second="${person_id}"/>
            <ConcatenateStrings first="${tf_start}" output="person_tf" second="/head"/>
            <Action ID="LookupTransform" output="transform" source_frame="${haru_tf}" target_frame="${person_tf}" use_last_available="true"/>
            <Action ID="GetTransformAngles" input="${transform}" pitch="pitch" roll="roll" yaw="yaw"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruGetPersonSpeech">
        <Sequence>
            <Action ID="ConvertMessageField" field="/speech/speaker_confidence" input="${person}" output="speaker_confidence"/>
            <Action ID="ConvertMessageField" field="/speech/asr_result/transcript" input="${person}" output="transcript_text"/>
            <Action ID="ConvertMessageField" field="/speech/asr_result/confidence" input="${person}" output="transcript_confidence"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruGetQRInfo">
        <Sequence>
            <Action ID="HaruCommandGetQRReading" serialized_output="qr_database_info" service="/qr_database_node/get_full_qr_data" timeout="{timeout}"/>
            <Action ID="ConvertMessageField" field="/qr_reading" input="{qr_database_info}" output="qr_info"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruGetSpeakingPerson">
        <Sequence>
            <SetBlackboard output_key="max_confidence" value="0"/>
            <SetBlackboard output_key="found_person" value="false"/>
            <SetBlackboard output_key="speaking_person" value=""/>
            <Decorator ID="ForEachLoop" break_on_child_failure="false" input="${people}" output_element="person_element" output_index="">
                <Sequence>
                    <SubTree ID="HaruGetPersonSpeech" person="{person_element}" speaker_confidence="new_confidence" transcript_confidence="dummy" transcript_text="transcript"/>
                    <CompareStrings comparison_op="!=" first="${transcript}" second=""/>
                    <CompareNumbers comparison_op="&gt;=" first="${new_confidence}" second="${max_confidence}"/>
                    <SetBlackboard output_key="max_confidence" value="${new_confidence}"/>
                    <SetBlackboard output_key="speaking_person" value="${person_element}"/>
                    <SetBlackboard output_key="found_person" value="true"/>
                    <Action ID="InfoLog" message="FOUND SPEAKING PERSON!"/>
                </Sequence>
            </Decorator>
            <CheckBool input="${found_person}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruGetTelegramUserList">
        <Sequence>
            <Action ID="HaruCommandTelegramGetUserList" serialized_output="output" service="/telegram_bot/get_user_list"/>
            <Action ID="ConvertMessageField" field="/users" input="${output}" output="user_list"/>
            <Action ID="ConvertMessageField" field="/success" input="${output}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruGoHome">
        <Action ID="PublishStdEmpty" latch="0" queue_size="1" topic="/idmind_tabletop/cmd_motors_home"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruLCDVideos">
        <Action ID="HaruCommandLCD" backlight="0" command="0" disable_eyes_roll_sync="0" end_time="0" latch="0" left_eye_file="${left_eye}" loop="false" queue_size="1" right_eye_file="${right_eye}" skip_factor="0" start_time="0" topic="/idmind_tabletop/cmd_lcd" transparency="0" wait_to_finish="0"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruLCDVideosAndWait">
        <Action ID="HaruCommandLCDAction" action="/idmind_tabletop/action_lcd" end_time="{end_time}" left_eye_file="{left_eye}" loop="{loop}" right_eye_file="{right_eye}" serialized_feedback="feedback" serialized_result="result" start_time="{start_time}" state="state" wait_to_finish="0"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruLCDVideosStop">
        <Action ID="HaruCommandLCD" backlight="0" command="2" disable_eyes_roll_sync="0" end_time="0" latch="0" left_eye_file="" loop="0" queue_size="1" right_eye_file="" skip_factor="0" start_time="0" topic="/idmind_tabletop/cmd_lcd" transparency="0" wait_to_finish="0"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruLEDsEyesPlay">
        <Action ID="HaruCommandLEDs" action="1" brightness="1" file="${eyes_file}" fps="0" jump_factor="0" latch="0" loop="0" queue_size="1" topic="/idmind_tabletop/cmd_leds" type="1"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruLEDsMouthPlay">
        <Action ID="HaruCommandLEDs" action="1" brightness="1" file="${mouth_file}" fps="0" jump_factor="0" latch="0" loop="0" queue_size="1" topic="/idmind_tabletop/cmd_leds" type="0"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruLEDsStop">
        <Fallback>
            <Sequence>
                <CompareStrings comparison_op="==" first="eyes" second="${part}"/>
                <Action ID="HaruCommandLEDs" action="2" brightness="1" file="" fps="0" jump_factor="0" latch="0" loop="0" queue_size="1" topic="/idmind_tabletop/cmd_leds" type="1"/>
            </Sequence>
            <Sequence>
                <CompareStrings comparison_op="==" first="mouth" second="${part}"/>
                <Action ID="HaruCommandLEDs" action="2" brightness="1" file="" fps="0" jump_factor="0" latch="0" loop="0" queue_size="1" topic="/idmind_tabletop/cmd_leds" type="0"/>
            </Sequence>
        </Fallback>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruListensEveryone">
        <Action ID="StrawberrySetSpeechTarget" serialized_output="dummy" service="/strawberry/set_speech_target" target="-1"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruListensNobody">
        <Action ID="StrawberrySetSpeechTarget" serialized_output="dummy" service="/strawberry/set_speech_target" target="-2"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruListensPerson">
        <Sequence>
            <Action ID="ConvertMessageField" field="/id" input="${person}" output="person_id"/>
            <Action ID="StrawberrySetSpeechTarget" serialized_output="dummy" service="/strawberry/set_speech_target" target="${person_id}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruLookAt">
        <Action ID="HaruCommandLookAt" base_control_vel="{base_control_vel}" disable_base="{disable_base}" disable_eyes="{disable_eyes}" disable_head="{disable_head}" disable_neck="{disable_neck}" objective.header.frame_id="" objective.header.seq="" objective.point.x="{horizontal}" objective.point.y="{proximity}" objective.point.z="{high}" service="idmind_tabletop/look_at"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruMarkTelegramMsgAsRead">
        <Sequence>
            <Action ID="HaruCommandTelegramMarkAsRead" msg_id="${msg_id}" serialized_output="output" service="/telegram_bot/mark_as_read"/>
            <Action ID="ConvertMessageField" field="/success" input="${output}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruNlpYesNo">
        <Sequence>
            <Action ID="HaruClassifyYesNoFromText" serialized_output="yesno_answer" service="/NlpClassifyYesNoFromText" transcription="{transcription}"/>
            <Action ID="ConvertMessageField" field="/predicted_intent" input="{yesno_answer}" output="answer"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruProjectorCloseWeb">
        <Sequence>
            <Action ID="PublishStdEmpty" latch="0" queue_size="1" topic="/idmind_tabletop/cmd_projector/web_browser/close"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruProjectorImage">
        <Action ID="HaruCommandProjector" backlight="0" command="0" end_time="${img_duration}" keep_last_frame="0" latch="0" loop="${always}" projector_file="${img_file}" queue_size="1" scale_type="${img_scale}" skip_factor="0" start_time="0" topic="/idmind_tabletop/cmd_projector" transparency="0" wait_to_finish="0"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruProjectorImageAndWait">
        <Action ID="HaruCommandProjectorAction" action="/idmind_tabletop/action_projector" end_time="{duration}" file="{image_file}" keep_last_frame="{keep_last}" loop="{loop}" scale_type="{image_scale}" serialized_feedback="feedback" serialized_result="result" start_time="0" state="state" wait_to_finish="0"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruProjectorShowLastWeb">
        <Action ID="PublishStdEmpty" latch="0" queue_size="1" topic="/idmind_tabletop/cmd_projector/web_browser/show"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruProjectorShowWeb">
        <Sequence>
            <Action ID="PublishStdString" data="{url}" latch="0" queue_size="1" topic="/idmind_tabletop/cmd_projector/web_browser/set_URL"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruProjectorStop">
        <Action ID="HaruCommandProjector" backlight="0" command="2" end_time="0" keep_last_frame="0" latch="0" loop="0" projector_file="" queue_size="1" scale_type="0" skip_factor="0" start_time="0" topic="/idmind_tabletop/cmd_projector" transparency="0" wait_to_finish="0"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruProjectorVideo">
        <Action ID="HaruCommandProjector" backlight="0" command="0" end_time="${end_time}" keep_last_frame="${keep_last}" latch="0" loop="${loop}" projector_file="${video_file}" queue_size="1" scale_type="${video_scale}" skip_factor="0" start_time="${start_time}" topic="/idmind_tabletop/cmd_projector" transparency="0" wait_to_finish="0"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruProjectorVideoAndWait">
        <Action ID="HaruCommandProjectorAction" action="/idmind_tabletop/action_projector" end_time="{end_time}" file="{video_file}" keep_last_frame="{keep_last}" loop="{loop}" scale_type="{video_scale}" serialized_feedback="feedback" serialized_result="result" start_time="{start_time}" state="state" wait_to_finish="0"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruReadQR">
        <Sequence>
            <Action ID="HaruCommandGetQRReading" serialized_output="qr_output" service="/scanner/read_qr" timeout="{timeout}"/>
            <Action ID="ConvertMessageField" field="/qr_reading" input="{qr_output}" output="qr_content"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruReceptionMainWebPage">
        <Sequence>
            <Action ID="HaruWebsiteShowGenericPage" serialized_output="output" service="/idmind_tabletop_website_node/show_main_page"/>
            <Action ID="ConvertMessageField" field="/success" input="{output}" output="success"/>
            <Action ID="ConvertMessageField" field="/website_url" input="{output}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruReceptionMeetingWebPage">
        <Sequence>
            <Action ID="HaruWebsiteShowMeetingPage" hosts="{hosts}" meeting_end="{meeting_end}" meeting_name="{meeting_name}" meeting_start="{meeting_start}" room="{room}" serialized_output="output" service="/idmind_tabletop_website_node/show_meeting_page" visitor_name="{guest_name}"/>
            <Action ID="ConvertMessageField" field="/success" input="{output}" output="success"/>
            <Action ID="ConvertMessageField" field="/website_url" input="{output}" output="website_url"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruReceptionProfileWebPage">
        <Sequence>
            <Action ID="HaruWebsiteShowProfilePage" company="{company}" guest_name="{guest_name}" image_location="{image_path}" position="{position}" serialized_output="output" service="/idmind_tabletop_website_node/show_profile_page"/>
            <Action ID="ConvertMessageField" field="/success" input="{output}" output="success"/>
            <Action ID="ConvertMessageField" field="/website_url" input="{output}" output="website_url"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruReceptionQRWebPage">
        <Sequence>
            <Action ID="HaruWebsiteShowGenericPage" serialized_output="output" service="/idmind_tabletop_website_node/show_scanqr_page"/>
            <Action ID="ConvertMessageField" field="/success" input="{output}" output="success"/>
            <Action ID="ConvertMessageField" field="/website_url" input="{output}" output="website_url"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruReceptionWeatherWebPage">
        <Sequence>
            <Action ID="HaruWebsiteShowGenericPage" serialized_output="output" service="/idmind_tabletop_website_node/show_weather_page"/>
            <Action ID="ConvertMessageField" field="/success" input="{output}" output="success"/>
            <Action ID="ConvertMessageField" field="/website_url" input="{output}" output="website_url"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruReceptionWelcomeWebPage">
        <Sequence>
            <Action ID="HaruWebsiteShowGenericPage" serialized_output="output" service="/idmind_tabletop_website_node/show_welcome_page"/>
            <Action ID="ConvertMessageField" field="/success" input="{output}" output="success"/>
            <Action ID="ConvertMessageField" field="/website_url" input="{output}" output="website_url"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruReceptionWifiWebPage">
        <Sequence>
            <Action ID="HaruWebsiteShowWifiPage" network="{network}" password="{password}" serialized_output="output" service="/idmind_tabletop_website_node/show_wifi_page"/>
            <Action ID="ConvertMessageField" field="/success" input="{output}" output="success"/>
            <Action ID="ConvertMessageField" field="/website_url" input="{output}" output="website_url"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruSendTelegramAudio">
        <Sequence>
            <Action ID="HaruCommandTelegramSendAudio" chat_id="${chat_id}" file_path="${file_path}" serialized_output="output" service="/telegram_bot/send_audio"/>
            <Action ID="ConvertMessageField" field="/success" input="${output}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruSendTelegramImage">
        <Sequence>
            <Action ID="HaruCommandTelegramSendImage" accepted="${accepted}" camera_topic_name="${camera_topic}" chat_id="${chat_id}" serialized_output="output" service="/telegram_bot/send_image"/>
            <Action ID="ConvertMessageField" field="/success" input="${output}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruSendTelegramText">
        <Sequence>
            <Action ID="HaruCommandTelegramSendText" chat_id="${chat_id}" serialized_output="output" service="/telegram_bot/send_text" text="${text}"/>
            <Action ID="ConvertMessageField" field="/success" input="${output}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruSetLanguage">
        <Action ID="HaruCommandSetLanguage" language="{language}" service="/idmind_tabletop/set_language"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruSetVoice">
        <Action ID="HaruCommandSetVoice" service="/idmind_tabletop/set_voice" voice="{voice}"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruSpeakExpressive">
        <Sequence>
            <Action ID="NLPTextToSSML" criteria_name="''" serialized_output="json" service="/nlp/text_to_ssml" text="${text}"/>
            <Action ID="InfoLog" message="${json}"/>
            <Action ID="ConvertMessageField" field="/ssml_text" input="${json}" output="exp_text"/>
            <Action ID="ConvertMessageField" field="/routine" input="{json}" output="exp_routine"/>
            <Parallel failure_threshold="1" success_threshold="2">
                <SubTree ID="HaruExecuteRoutineAndWait" feedback="routine_feed" result="routine_result" routines="${exp_routine}"/>
                <SubTree ID="HaruSpeaksTTSAndWait" feedback="tts_feed" phrases="${exp_text}" result="tts_result"/>
            </Parallel>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruSpeaksEmoTTSAndWait">
        <Sequence name="">
            <RandomSequenceValue delimiter=";" name="" output="sentence" sequence="{phrases}"/>
            <Concatenate5Strings first="&lt;usel genre=&quot;" name="" output="sentence_genre" second="{genre}" string_3="&quot;&gt; " string_4="{sentence}" string_5=" &lt;/usel&gt;"/>
            <Action ID="HaruCommandTTSAction" action="/idmind_tabletop/action_tts" message="{sentence_genre}" name="" serialized_feedback="feedback" serialized_result="result" state="state"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruSpeaksTTS">
        <Sequence>
            <RandomSequenceValue delimiter=";" output="tts_cmd" sequence="${phrases}"/>
            <ConcatenateStrings first="TTS speaking: " output="message" second="${tts_cmd}"/>
            <Action ID="InfoLog" message="${message}"/>
            <Action ID="HaruCommandTTS" latch="0" message="${tts_cmd}" queue_size="1" topic="/idmind_tabletop/cmd_tts"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruSpeaksTTSAndWait">
        <Sequence>
            <RandomSequenceValue delimiter=";" output="sentence" sequence="{phrases}"/>
            <Action ID="HaruCommandTTSAction" action="/idmind_tabletop/action_tts" message="{sentence}" serialized_feedback="feedback" serialized_result="result" state="state"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruSpeaksTTSAndWaitDEPRECATE">
        <Sequence>
            <RandomSequenceValue delimiter=";" output="tts_cmd" sequence="${phrases}"/>
            <Action ID="HaruCommandTTSService" message="${tts_cmd}" serialized_output="service_response" service="/idmind_tabletop/cmd_tts_blocking_srv"/>
            <Action ID="ConvertMessageField" field="/played" input="{service_response}" output="tts_played"/>
            <Action ID="InfoLog" message="${tts_played}"/>
            <CheckBool input="${tts_played}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruStartTimeCount">
        <Action ID="HaruCommandCountTime" command.data="0" serialized_output="output" service="/timer_ros_node/trigger_timer" timer_id.data="{timer_id}"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruStopTimeCount">
        <Sequence>
            <Action ID="HaruCommandCountTime" command.data="1" serialized_output="output" service="/timer_ros_node/trigger_timer" timer_id.data="{timer_id}"/>
            <Action ID="ConvertMessageField" field="/time_elapsed/data" input="{output}" output="time_elapsed"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruStopsRoutines">
        <Action ID="CallEmptyService" service="/idmind_tabletop/stop_routines"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruStopsTracking">
        <Action ID="HaruCommandTrack" command="2" latch="0" queue_size="1" topic="/idmind_tabletop/cmd_track" track_frame=""/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruSwitchAudioDucking">
        <Sequence>
            <Action ID="HaruCommandSwitchAudioDucking" enable="{enable}" main_channel_id="{main_channel_id}" serialized_output="output" service="/idmind_tabletop/switch_audio_ducking"/>
            <Action ID="ConvertMessageField" field="/success" input="{output}" output="switch_success"/>
            <CheckBool input="{switch_success}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruTakePhoto">
        <Sequence>
            <Action ID="InfoLog" message="Saving picture"/>
            <Action ID="CaptureImage" cmd="true" num_name="${image_name}" path="${path}" service="/image_cmd"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruTrackPerson">
        <Sequence>
            <Action ID="ConvertMessageField" field="/id" input="${person}" output="person_id"/>
            <Action ID="ConvertMessageField" field="/frame_id" input="${person_header}" output="person_frame_id"/>
            <ConcatenateStrings first="${person_frame_id}" output="track_frame_1" second="/skeletons/"/>
            <ConcatenateStrings first="${track_frame_1}" output="track_frame_2" second="${person_id}"/>
            <ConcatenateStrings first="${track_frame_2}" output="track_frame_3" second="/"/>
            <ConcatenateStrings first="${track_frame_3}" output="track_frame" second="${body_part}"/>
            <Action ID="HaruCommandTrack" command="0" latch="0" queue_size="1" topic="/idmind_tabletop/cmd_track" track_frame="${track_frame}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruTrackPosition">
        <Action ID="HaruCommandTrack" command="0" latch="0" queue_size="1" topic="/idmind_tabletop/cmd_track" track_frame="${frame}"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="HaruTrackVelocity">
        <Action ID="HaruCommandTrack" command="1" latch="0" queue_size="1" topic="/idmind_tabletop/cmd_track" track_frame="${frame}"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="IsHaruAudioPlaying">
        <ReactiveSequence>
            <RetryUntilSuccessful num_attempts="10">
                <Fallback>
                    <Action ID="HaruMonitorAudio" consume_msgs="0" queue_size="1" serialized_output="audio_status_msg" topic="/idmind_tabletop/audio_status"/>
                    <ForceFailure>
                        <WaitMilliseconds duration="200"/>
                    </ForceFailure>
                </Fallback>
            </RetryUntilSuccessful>
            <Sequence>
                <Action ID="GetMessageField" field="/status" input="${audio_status_msg}" output="audio_status"/>
                <Action ID="ConvertJsonToUint64" input="${audio_status}" output="audio_status_uint"/>
                <CompareNumbers comparison_op="==" first="${audio_status_uint}" second="0"/>
            </Sequence>
        </ReactiveSequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="IsHaruLCDPlaying">
        <ReactiveSequence>
            <RetryUntilSuccessful num_attempts="10">
                <Fallback>
                    <Action ID="HaruMonitorLCD" consume_msgs="0" queue_size="1" serialized_output="lcd_status_msg" topic="/idmind_tabletop/lcd_status"/>
                    <ForceFailure>
                        <WaitMilliseconds duration="200"/>
                    </ForceFailure>
                </Fallback>
            </RetryUntilSuccessful>
            <Sequence>
                <Action ID="GetMessageField" field="/status" input="${lcd_status_msg}" output="lcd_status"/>
                <Action ID="ConvertJsonToUint64" input="${lcd_status}" output="lcd_status_uint"/>
                <CompareNumbers comparison_op="==" first="${lcd_status_uint}" second="0"/>
            </Sequence>
        </ReactiveSequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="IsHaruProjectorPlaying">
        <ReactiveSequence>
            <RetryUntilSuccessful num_attempts="10">
                <Fallback>
                    <Action ID="HaruMonitorProjector" consume_msgs="0" queue_size="1" serialized_output="projector_status_msg" topic="/idmind_tabletop/projector_status"/>
                    <ForceFailure>
                        <WaitMilliseconds duration="200"/>
                    </ForceFailure>
                </Fallback>
            </RetryUntilSuccessful>
            <Sequence>
                <Action ID="ConvertMessageField" field="/status" input="${projector_status_msg}" output="projector_status"/>
                <CompareNumbers comparison_op="==" first="${projector_status}" second="0"/>
            </Sequence>
        </ReactiveSequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="IsHaruRoutinePlaying">
        <ReactiveSequence>
            <RetryUntilSuccessful num_attempts="10">
                <Fallback>
                    <Action ID="HaruMonitorRoutine" consume_msgs="0" queue_size="1" serialized_output="routine_status_msg" topic="/idmind_tabletop/routine_status"/>
                    <ForceFailure>
                        <WaitMilliseconds duration="200"/>
                    </ForceFailure>
                </Fallback>
            </RetryUntilSuccessful>
            <Sequence>
                <Action ID="GetMessageField" field="/progress" input="${routine_status_msg}" output="routine_status"/>
                <Action ID="ConvertJsonToDouble" input="${routine_status}" output="routine_status_double"/>
                <CompareNumbers comparison_op="&lt;" first="${routine_status_double}" second="1.0"/>
            </Sequence>
        </ReactiveSequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="IsHaruSpeaking">
        <ReactiveSequence>
            <RetryUntilSuccessful num_attempts="10">
                <Fallback>
                    <Action ID="HaruMonitorTTS" consume_msgs="0" queue_size="1" serialized_output="_tts_status_msg" topic="/idmind_tabletop/tts_status"/>
                    <ForceFailure>
                        <WaitMilliseconds duration="200"/>
                    </ForceFailure>
                </Fallback>
            </RetryUntilSuccessful>
            <Sequence>
                <Action ID="GetMessageField" field="/status" input="${_tts_status_msg}" output="_tts_status"/>
                <Action ID="ConvertJsonToDouble" input="${_tts_status}" output="_tts_status_double"/>
                <CompareNumbers comparison_op="==" first="${_tts_status_double}" second="2"/>
            </Sequence>
        </ReactiveSequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="IsHaruTracking">
        <ReactiveSequence>
            <RetryUntilSuccessful num_attempts="10">
                <Fallback>
                    <Action ID="HaruMonitorTrack" consume_msgs="0" queue_size="1" serialized_output="track_status_msg" topic="/idmind_tabletop/track_status"/>
                    <ForceFailure>
                        <WaitMilliseconds duration="100"/>
                    </ForceFailure>
                </Fallback>
            </RetryUntilSuccessful>
            <Action ID="ConvertMessageField" field="/tracking" input="${track_status_msg}" output="track_status"/>
            <CheckBool input="${track_status}"/>
        </ReactiveSequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="IstCleanupText">
        <Sequence>
            <Action ID="TextCleanupApiCallAction" action="/ist_cleanup_py" sentence="{sentence}" serialized_feedback="feedback" serialized_result="result" state="state"/>
            <Action ID="ConvertMessageField" field="/cleaned_sentence" input="{result}" output="cleaned_sentence"/>
            <Action ID="ConvertMessageField" field="/input_flag" input="{result}" output="input_flag"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="IstSendToHaru">
        <Sequence>
            <Action ID="IstApiCallAction" action="/ist_server_py" sentence="{sentence}" serialized_feedback="feedback" serialized_result="result" state="state" to_filter="{to_filter}"/>
            <Action ID="ConvertMessageField" field="/answer_haru" input="{result}" output="answer_haru"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="IstSteeredSendToHaru">
        <Sequence>
            <Action ID="IstSteeredApiCallAction" action="/ist_server_py" emotion_wished="{emotion_wished}" sentence="{sentence}" serialized_feedback="feedback" serialized_result="result" state="state" to_filter="{to_filter}"/>
            <Action ID="ConvertMessageField" field="/answer_haru" input="{result}" output="answer_haru"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiCheckPersonHasMaskById">
        <Sequence>
            <Action ID="PeopleApiCallCheckPersonHasMaskById" person_id="{person_id}" serialized_output="json" service="/strawberry/check_person_has_mask_by_id"/>
            <Action ID="ConvertMessageField" field="/has_mask" input="{json}" output="has_mask"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiCheckPersonHasMaskByName">
        <Sequence>
            <Action ID="PeopleApiCallCheckPersonHasMaskByName" person_name="{person_name}" serialized_output="json" service="/strawberry/check_person_has_mask_by_name"/>
            <Action ID="ConvertMessageField" field="/has_mask" input="{json}" output="has_mask"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiCheckPersonIsFemaleById">
        <Sequence>
            <Action ID="PeopleApiCallCheckPersonIsFemaleById" person_id="{person_id}" serialized_output="json" service="/strawberry/check_person_is_female_by_id"/>
            <Action ID="ConvertMessageField" field="/is_female" input="{json}" output="is_female"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiCheckPersonIsFemaleByName">
        <Sequence>
            <Action ID="PeopleApiCallCheckPersonIsFemaleByName" person_name="{person_name}" serialized_output="json" service="/strawberry/check_person_is_female_by_name"/>
            <Action ID="ConvertMessageField" field="/is_female" input="{json}" output="is_female"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiCheckPersonIsLookingAtById">
        <Sequence>
            <Action ID="PeopleApiCallCheckPersonInteractionById" axis="{axis}" person_id="{person_id}" point.x="{source_x}" point.y="{source_y}" point.z="{source_z}" serialized_output="json" service="/strawberry/check_person_is_looking_at_by_id" tolerance="{tolerance}"/>
            <Action ID="ConvertMessageField" field="/success" input="{json}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiCheckPersonIsLookingAtByName">
        <Sequence>
            <Action ID="PeopleApiCallCheckPersonInteractionByName" axis="{axis}" person_name="{person_name}" point.x="{source_x}" point.y="{source_y}" point.z="{source_z}" serialized_output="json" service="/strawberry/check_person_is_looking_at_by_name" tolerance="{tolerance}"/>
            <Action ID="ConvertMessageField" field="/success" input="{json}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiCheckPersonIsNearToById">
        <Sequence>
            <Action ID="PeopleApiCallCheckPersonInteractionById" axis="{axis}" person_id="{person_id}" point.x="{source_x}" point.y="{source_y}" point.z="{source_z}" serialized_output="json" service="/strawberry/check_person_is_near_to_by_id" tolerance="{tolerance}"/>
            <Action ID="ConvertMessageField" field="/success" input="{json}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiCheckPersonIsNearToByName">
        <Sequence>
            <Action ID="PeopleApiCallCheckPersonInteractionByName" axis="{axis}" person_name="{person_name}" point.x="{source_x}" point.y="{source_y}" point.z="{source_z}" serialized_output="json" service="/strawberry/check_person_is_near_to_by_name" tolerance="{tolerance}"/>
            <Action ID="ConvertMessageField" field="/success" input="{json}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiCheckPersonIsPointingToById">
        <Sequence>
            <Action ID="PeopleApiCallCheckPersonInteractionById" axis="{axis}" person_id="{person_id}" point.x="{source_x}" point.y="{source_y}" point.z="{source_z}" serialized_output="json" service="/strawberry/check_person_is_pointing_to_by_id" tolerance="{tolerance}"/>
            <Action ID="ConvertMessageField" field="/success" input="{json}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiCheckPersonIsPointingToByName">
        <Sequence>
            <Action ID="PeopleApiCallCheckPersonInteractionByName" axis="{axis}" person_name="{person_name}" point.x="{source_x}" point.y="{source_y}" point.z="{source_z}" serialized_output="json" service="/strawberry/check_person_is_pointing_to_by_name" tolerance="{tolerance}"/>
            <Action ID="ConvertMessageField" field="/success" input="{json}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetClosestPerson">
        <Sequence>
            <Action ID="PeopleApiCallGetClosestPerson" serialized_output="json" service="/strawberry/get_closest_person" source_pos.x="{source_x}" source_pos.y="{source_y}" source_pos.z="{source_z}"/>
            <Action ID="ConvertMessageField" field="/person_id" input="{json}" output="person_id"/>
            <Action ID="ConvertMessageField" field="/person_name" input="{json}" output="person_name"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetIdAndNameLists">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonIdAndNameList" serialized_output="json" service="/strawberry/get_persons_id_and_names"/>
            <Action ID="ConvertMessageField" field="/named_ids" input="{json}" output="tmp_named_ids"/>
            <Action ID="InitializeJson" name="Ids Json" output="tmp_ids"/>
            <Action ID="InitializeJson" name="Names Json" output="tmp_names"/>
            <Decorator ID="ForEachLoop" break_on_child_failure="false" input="{tmp_named_ids}" output_element="named_id" output_index="">
                <Sequence>
                    <Action ID="ConvertMessageField" field="/id" input="{named_id}" output="id"/>
                    <Action ID="InfoLog" message="{id}" name="Extracted Id"/>
                    <Action ID="AddArrayToJson" input_json="{tmp_ids}" input_key="" input_value="{id}" output_json="tmp_ids" override="0"/>
                    <Action ID="ConvertMessageField" field="/name" input="{named_id}" output="name"/>
                    <Action ID="AddArrayToJson" input_json="{tmp_names}" input_key="" input_value="{name}" output_json="tmp_names" override="0"/>
                    <Action ID="InfoLog" message="{name}" name="Extracted Name"/>
                </Sequence>
            </Decorator>
            <SetBlackboard output_key="names_and_ids" value="{tmp_named_ids}"/>
            <SetBlackboard output_key="ids" value="{tmp_ids}"/>
            <SetBlackboard output_key="names" value="{tmp_names}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetNumberOfPersons">
        <Sequence>
            <Action ID="PeopleApiCallGetNumberOfPersons" serialized_output="json" service="/strawberry/get_number_of_persons"/>
            <Action ID="ConvertMessageField" field="/value" input="{json}" output="value"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonBodyPartPosByID">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonBodyPartPosById" body_part="{body_part_name}" person_id="{person_id}" serialized_output="json" service="/strawberry/get_person_body_part_pos_by_id"/>
            <Action ID="ConvertMessageField" field="/body_part_pos/x" input="{json}" output="x"/>
            <Action ID="ConvertMessageField" field="/body_part_pos/y" input="{json}" output="y"/>
            <Action ID="ConvertMessageField" field="/body_part_pos/z" input="{json}" output="z"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonBodyPartPosByName">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonBodyPartPosByName" body_part="{body_part_name}" person_name="{person_name}" serialized_output="json" service="/strawberry/get_person_body_part_pos_by_name"/>
            <Action ID="ConvertMessageField" field="/body_part_pos/x" input="{json}" output="x"/>
            <Action ID="ConvertMessageField" field="/body_part_pos/y" input="{json}" output="y"/>
            <Action ID="ConvertMessageField" field="/body_part_pos/z" input="{json}" output="z"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonEmotionById">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonEmotionById" person_id="{person_id}" serialized_output="json" service="/strawberry/get_person_emotion_by_id"/>
            <Action ID="ConvertMessageField" field="/emotion" input="{json}" output="emotion_name"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonEmotionByName">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonEmotionByName" person_name="{person_name}" serialized_output="json" service="/strawberry/get_person_emotion_by_name"/>
            <Action ID="ConvertMessageField" field="/emotion" input="{json}" output="emotion_name"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonGestureById">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonGestureById" person_id="{person_id}" serialized_output="json" service="/strawberry/get_person_gesture_by_id"/>
            <Action ID="ConvertMessageField" field="/gesture" input="{json}" output="gesture_name"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonGestureByName">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonGestureByName" person_name="{person_name}" serialized_output="json" service="/strawberry/get_person_gesture_by_name"/>
            <Action ID="ConvertMessageField" field="/gesture" input="{json}" output="gesture_name"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonHandsDirById">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonHandsDirById" person_id="{person_id}" serialized_output="json" service="/strawberry/get_person_hands_dir_by_id"/>
            <Action ID="ConvertMessageField" field="/r_hand_dir/x" input="{json}" output="right_hand_x"/>
            <Action ID="ConvertMessageField" field="/r_hand_dir/y" input="{json}" output="right_hand_y"/>
            <Action ID="ConvertMessageField" field="/r_hand_dir/z" input="{json}" output="right_hand_z"/>
            <Action ID="ConvertMessageField" field="/l_hand_dir/x" input="{json}" output="left_hand_x"/>
            <Action ID="ConvertMessageField" field="/l_hand_dir/y" input="{json}" output="left_hand_y"/>
            <Action ID="ConvertMessageField" field="/l_hand_dir/z" input="{json}" output="left_hand_z"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonHandsDirByName">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonHandsDirByName" person_name="{person_name}" serialized_output="json" service="/strawberry/get_person_hands_dir_by_name"/>
            <Action ID="ConvertMessageField" field="/r_hand_dir/x" input="{json}" output="right_hand_x"/>
            <Action ID="ConvertMessageField" field="/r_hand_dir/y" input="{json}" output="right_hand_y"/>
            <Action ID="ConvertMessageField" field="/r_hand_dir/z" input="{json}" output="right_hand_z"/>
            <Action ID="ConvertMessageField" field="/l_hand_dir/x" input="{json}" output="left_hand_x"/>
            <Action ID="ConvertMessageField" field="/l_hand_dir/y" input="{json}" output="left_hand_y"/>
            <Action ID="ConvertMessageField" field="/l_hand_dir/z" input="{json}" output="left_hand_z"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonHandsPosById">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonHandsPosById" person_id="{person_id}" serialized_output="json" service="/strawberry/get_person_hands_pos_by_id"/>
            <Action ID="ConvertMessageField" field="/r_hand_pos/x" input="{json}" output="right_hand_x"/>
            <Action ID="ConvertMessageField" field="/r_hand_pos/y" input="{json}" output="right_hand_y"/>
            <Action ID="ConvertMessageField" field="/r_hand_pos/z" input="{json}" output="right_hand_z"/>
            <Action ID="ConvertMessageField" field="/l_hand_pos/x" input="{json}" output="left_hand_x"/>
            <Action ID="ConvertMessageField" field="/l_hand_pos/y" input="{json}" output="left_hand_y"/>
            <Action ID="ConvertMessageField" field="/l_hand_pos/z" input="{json}" output="left_hand_z"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonHandsPosByName">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonHandsPosByName" person_name="{person_name}" serialized_output="json" service="/strawberry/get_person_hands_pos_by_name"/>
            <Action ID="ConvertMessageField" field="/r_hand_pos/x" input="{json}" output="right_hand_x"/>
            <Action ID="ConvertMessageField" field="/r_hand_pos/y" input="{json}" output="right_hand_y"/>
            <Action ID="ConvertMessageField" field="/r_hand_pos/z" input="{json}" output="right_hand_z"/>
            <Action ID="ConvertMessageField" field="/l_hand_pos/x" input="{json}" output="left_hand_x"/>
            <Action ID="ConvertMessageField" field="/l_hand_pos/y" input="{json}" output="left_hand_y"/>
            <Action ID="ConvertMessageField" field="/l_hand_pos/z" input="{json}" output="left_hand_z"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonHeadDirById">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonHeadDirById" person_id="{person_id}" serialized_output="json" service="/strawberry/get_person_head_dir_by_id"/>
            <Action ID="ConvertMessageField" field="/head_dir/x" input="{json}" output="x"/>
            <Action ID="ConvertMessageField" field="/head_dir/y" input="{json}" output="y"/>
            <Action ID="ConvertMessageField" field="/head_dir/z" input="{json}" output="z"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonHeadDirByName">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonHeadDirByName" person_name="{person_name}" serialized_output="json" service="/strawberry/get_person_head_dir_by_name"/>
            <Action ID="ConvertMessageField" field="/head_dir/x" input="{json}" output="x"/>
            <Action ID="ConvertMessageField" field="/head_dir/y" input="{json}" output="y"/>
            <Action ID="ConvertMessageField" field="/head_dir/z" input="{json}" output="z"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonHeadPosById">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonHeadPosById" person_id="{person_id}" serialized_output="json" service="/strawberry/get_person_head_pos_by_id"/>
            <Action ID="ConvertMessageField" field="/head_pos/x" input="{json}" output="x"/>
            <Action ID="ConvertMessageField" field="/head_pos/y" input="{json}" output="y"/>
            <Action ID="ConvertMessageField" field="/head_pos/z" input="{json}" output="z"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonHeadPosByName">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonHeadPosByName" person_name="{person_name}" serialized_output="json" service="/strawberry/get_person_head_pos_by_name"/>
            <Action ID="ConvertMessageField" field="/head_pos/x" input="{json}" output="x"/>
            <Action ID="ConvertMessageField" field="/head_pos/y" input="{json}" output="y"/>
            <Action ID="ConvertMessageField" field="/head_pos/z" input="{json}" output="z"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonIdByName">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonIdByName" person_name="{person_name}" serialized_output="json" service="/strawberry/get_person_id_by_name"/>
            <Action ID="ConvertMessageField" field="/person_id" input="{json}" output="person_id"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonNameById">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonNameById" person_id="{person_id}" serialized_output="json" service="/strawberry/get_person_name_by_id"/>
            <Action ID="ConvertMessageField" field="/person_name" input="{json}" output="person_name"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonPosById">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonPosById" person_id="{person_id}" serialized_output="json" service="/strawberry/get_person_pos_by_id"/>
            <Action ID="ConvertMessageField" field="/position/x" input="{json}" output="x"/>
            <Action ID="ConvertMessageField" field="/position/y" input="{json}" output="y"/>
            <Action ID="ConvertMessageField" field="/position/z" input="{json}" output="z"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonPosByName">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonPosByName" person_name="{person_name}" serialized_output="json" service="/strawberry/get_person_pos_by_name"/>
            <Action ID="ConvertMessageField" field="/position/x" input="{json}" output="x"/>
            <Action ID="ConvertMessageField" field="/position/y" input="{json}" output="y"/>
            <Action ID="ConvertMessageField" field="/position/z" input="{json}" output="z"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonSpeechByIdAndWait">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonSpeechByIdAction" action="/strawberry/get_person_speech_by_id" person_id="{person_id}" serialized_feedback="feedback" serialized_result="result" state="state" timeout="{timeout}"/>
            <Action ID="ConvertMessageField" field="/success" input="{result}" output="success"/>
            <Action ID="ConvertMessageField" field="/speech_seq" input="{result}" output="speech_id"/>
            <Action ID="ConvertMessageField" field="/speech_text" input="{result}" output="speech_text"/>
            <Action ID="ConvertMessageField" field="/speech_confidence" input="{result}" output="speech_confidence"/>
            <Action ID="ConvertMessageField" field="/speaker_confidence" input="{result}" output="speaker_confidence"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonSpeechByNameAndWait">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonSpeechByNameAction" action="/strawberry/get_person_speech_by_name" person_name="{person_name}" serialized_feedback="feedback" serialized_result="result" state="state" timeout="{timeout}"/>
            <Action ID="ConvertMessageField" field="/success" input="{result}" output="success"/>
            <Action ID="ConvertMessageField" field="/speech_seq" input="{result}" output="speech_id"/>
            <Action ID="ConvertMessageField" field="/speech_text" input="{result}" output="speech_text"/>
            <Action ID="ConvertMessageField" field="/speech_confidence" input="{result}" output="speech_confidence"/>
            <Action ID="ConvertMessageField" field="/speaker_confidence" input="{result}" output="speaker_confidence"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonSpeechMaxConfidenceAndWait">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonSpeechMaxConfidenceAction" action="/strawberry/get_person_speech_max_confidence" serialized_feedback="feedback" serialized_result="result" state="state" timeout="{timeout}"/>
            <Action ID="ConvertMessageField" field="/success" input="{result}" output="success"/>
            <Action ID="ConvertMessageField" field="/person_id" input="{result}" output="person_id"/>
            <Action ID="ConvertMessageField" field="/person_name" input="{result}" output="person_name"/>
            <Action ID="ConvertMessageField" field="/speech_seq" input="{result}" output="speech_id"/>
            <Action ID="ConvertMessageField" field="/speech_text" input="{result}" output="speech_text"/>
            <Action ID="ConvertMessageField" field="/speech_confidence" input="{result}" output="speech_confidence"/>
            <Action ID="ConvertMessageField" field="/speaker_confidence" input="{result}" output="speaker_confidence"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="PeopleApiGetPersonWakeUpWordAndWait">
        <Sequence>
            <Action ID="PeopleApiCallGetPersonWakeUpWordAction" action="/strawberry/get_person_wake_up_word" serialized_feedback="feedback" serialized_result="result" state="state" timeout="{timeout}"/>
            <Action ID="ConvertMessageField" field="/person_found" input="{result}" output="person_found"/>
            <Action ID="ConvertMessageField" field="/person_id" input="{result}" output="person_id"/>
            <Action ID="ConvertMessageField" field="/person_name" input="{result}" output="person_name"/>
            <Action ID="ConvertMessageField" field="/wake_up_word" input="{result}" output="wake_up_word"/>
            <Action ID="ConvertMessageField" field="/speech_seq" input="{result}" output="speech_id"/>
            <Action ID="ConvertMessageField" field="/speech_text" input="{result}" output="speech_text"/>
            <Action ID="ConvertMessageField" field="/speech_confidence" input="{result}" output="speech_confidence"/>
            <Action ID="ConvertMessageField" field="/speaker_confidence" input="{result}" output="speaker_confidence"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="RosTeleconferenceAudioOFF">
        <Action ID="CallTriggerService" serialized_output="output" service="/teleconference/set_pause_audio"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="RosTeleconferenceAudioON">
        <Action ID="CallTriggerService" serialized_output="output" service="/teleconference/set_resume_audio"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="RosTeleconferenceSyncBuffReset">
        <Action ID="CallEmptyService" service="/teleconference_sync/refresh"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="SaveImage">
        <Sequence>
            <Action ID="HaruCommandSaveImage" file="{image_file}" serialized_output="output" service="/image_saver/save_image" topic="{image_topic}"/>
            <Action ID="ConvertMessageField" field="/success" input="{output}" output="success"/>
            <CheckBool input="{success}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryASRToDialog">
        <Sequence>
            <Action ID="ConvertMessageField" field="/transcript" input="${asr_result_msg}" output="asr_result_transcript"/>
            <Action ID="ConvertMessageField" field="/confidence" input="${asr_result_msg}" output="asr_result_conf"/>
            <Action ID="ConvertMessageField" field="/header/frame_id" input="${asr_result_msg}" output="asr_result_fram_id"/>
            <Action ID="ConvertMessageField" field="/header/seq" input="${asr_result_msg}" output="asr_result_seq"/>
            <Action ID="StrawberryCommandSpeech" asr_result.confidence="${asr_result_conf}" asr_result.header.frame_id="${asr_result_fram_id}" asr_result.header.seq="${asr_result_seq}" asr_result.transcript="${asr_result_transcript}" latch="0" person_id="0" queue_size="1" speaker_confidence="0" topic="/strawberry/dialog_input" wake_up_word="0"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryAddDialogEntity">
        <Sequence>
            <Action ID="StrawberryControlEntity" action="ADD" auto_expansion_mode="{auto_expansion}" enable_fuzzy_extraction="{fuzzy_extraction}" entities="{entities}" entity_name="{entity_name}" kind="{kind}" serialized_output="srv_output" service="/strawberry/control_entity"/>
            <Action ID="ConvertMessageField" field="/success" input="{srv_output}" output="srv_success"/>
            <CheckBool input="{srv_success}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryAppendDialogSessionEntity">
        <Sequence>
            <Action ID="StrawberryControlSessionEntity" action="ADD" entities="{entities}" entity_name="{entity_name}" entity_override_mode="SUPPLEMENT" person_id="{person_id}" serialized_output="srv_output" service="/strawberry/control_session_entity"/>
            <Action ID="ConvertMessageField" field="/success" input="{srv_output}" output="srv_success"/>
            <CheckBool input="{srv_success}"/>
            <Action ID="ConvertMessageField" field="/entity_types" input="{srv_output}" output="session_entities"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryDialogAskYesNoQuestion">
        <Sequence>
            <OnlyOnce>
                <Sequence name="Variable creation">
                    <SetBlackboard name="Create dialog_response var" output_key="dialog_response" value=""/>
                    <SetBlackboard name="Create dialog_result var" output_key="dialog_result" value=""/>
                    <SetBlackboard name="Create dialog_intent var" output_key="dialog_intent" value=""/>
                    <SetBlackboard output_key="success" value=""/>
                </Sequence>
            </OnlyOnce>
            <Sequence name="Ask the question">
                <Action ID="InitializeJson" output="question_input"/>
                <Action ID="AddKeyValueToJson" input_json="${question_input}" input_key="question" input_value="{question}" output="question_input"/>
                <Parallel failure_threshold="2" success_threshold="2">
                    <Sequence>
                        <OnlyOnce>
                            <WaitMilliseconds duration="400" name="Wait for the dialog subscriber creation"/>
                        </OnlyOnce>
                        <SubTree ID="StrawberrySetDialogEvent" event_name="command-generic-yes-no" parameters="${question_input}" person_id="0" result="dialog_result" success="success"/>
                    </Sequence>
                    <Inverter>
                        <WhileSuccess>
                            <Inverter>
                                <Sequence name="Get Dialog">
                                    <SubTree ID="StrawberryGetDialog" dialog_response="dialog_response_tmp" dialog_result="dialog_result_tmp"/>
                                    <SubTree ID="StrawberryGetDialogIntent" dialog_intent="dialog_intent" dialog_intent_confidence="dialog_intent_conf" dialog_result="{dialog_result_tmp}"/>
                                    <CompareStrings comparison_op="==" first="command-generic-yes-no" name="Check the intent is the event name" second="{dialog_intent}"/>
                                    <SetBlackboard output_key="dialog_response" value="${dialog_response_tmp}"/>
                                    <SetBlackboard output_key="dialog_result" value="${dialog_result_tmp}"/>
                                </Sequence>
                            </Inverter>
                        </WhileSuccess>
                    </Inverter>
                </Parallel>
                <Action ID="HaruCommandTTS" latch="0" message="{question}" queue_size="1" topic="/idmind_tabletop/cmd_tts"/>
            </Sequence>
            <Sequence name="Wait for and process a reply">
                <Inverter>
                    <WhileSuccess>
                        <Inverter>
                            <Sequence>
                                <SubTree ID="StrawberryGetDialog" dialog_response="dialog_response_tmp" dialog_result="dialog_result_tmp"/>
                                <SubTree ID="StrawberryGetDialogIntent" dialog_intent="dialog_intent" dialog_intent_confidence="dialog_intent_conf" dialog_result="{dialog_result_tmp}"/>
                                <CompareStrings comparison_op="!=" first="command-generic-yes-no-fallback" name="Check for local fallback" second="{dialog_intent}"/>
                            </Sequence>
                        </Inverter>
                    </WhileSuccess>
                </Inverter>
            </Sequence>
            <Sequence name="Succeed/fail based on detected intent">
                <CompareStrings comparison_op="==" first="command-generic-yes" name="Subtree should succeed if speaker said &quot;yes&quot; and fail for anything else" second="{dialog_intent}"/>
            </Sequence>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryDisableASR">
        <Action ID="StrawberryCommandEnableASR" data="0" header.frame_id="bt" header.seq="0" latch="0" queue_size="1" topic="/strawberry/enable_asr"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryDisableAllASR">
        <Action ID="StrawberryCommandEnableASR" data="0" header.frame_id="bt" header.seq="0" latch="0" queue_size="1" topic="/strawberry/enable_asr_all"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryDisableDialogGenericQuestions">
        <Action ID="CallEmptyService" service="/strawberry/disable_question_gen"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryEnableASR">
        <Action ID="StrawberryCommandEnableASR" data="1" header.frame_id="bt" header.seq="0" latch="0" queue_size="1" topic="/strawberry/enable_asr"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryEnableAllASR">
        <Action ID="StrawberryCommandEnableASR" data="1" header.frame_id="bt" header.seq="0" latch="0" queue_size="1" topic="/strawberry/enable_asr_all"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetASR">
        <Sequence>
            <Action ID="StrawberryMonitorASR" consume_msgs="1" queue_size="1" serialized_output="asr_result_msg_inter" topic="/strawberry/asr_result"/>
            <Action ID="ConvertMessageField" field="/transcript" input="${asr_result_msg_inter}" output="asr_result"/>
            <Action ID="ConvertMessageField" field="/confidence" input="${asr_result_msg_inter}" output="asr_result_conf"/>
            <SetBlackboard output_key="asr_result_msg" value="${asr_result_msg_inter}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetDialog">
        <Sequence>
            <SetBlackboard output_key="dialog_result" value=""/>
            <Action ID="StrawberryMonitorDialogue" consume_msgs="1" queue_size="1" serialized_output="dialog_result_msg" topic="/strawberry/dialog_result"/>
            <Action ID="ConvertMessageField" field="/fulfillment_text" input="${dialog_result_msg}" output="dialog_response"/>
            <SetBlackboard output_key="dialog_result" value="${dialog_result_msg}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetDialogIntent">
        <Sequence>
            <SetBlackboard output_key="dialog_intent" value=""/>
            <SetBlackboard output_key="dialog_intent_confidence" value=""/>
            <Action ID="ConvertMessageField" field="/slu_result/intent" input="${dialog_result}" output="dialog_intent"/>
            <Action ID="ConvertMessageField" field="/slu_result/intent_conf" input="${dialog_result}" output="dialog_intent_confidence"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetDialogSessionEntity">
        <Sequence>
            <Action ID="InitializeJson" output="empty_json"/>
            <Action ID="StrawberryControlSessionEntity" action="GET" entities="{empty_json}" entity_name="all" entity_override_mode="SUPPLEMENT" person_id="{person_id}" serialized_output="srv_output" service="/strawberry/control_session_entity"/>
            <Action ID="ConvertMessageField" field="/success" input="{srv_output}" output="srv_success"/>
            <CheckBool input="{srv_success}"/>
            <Action ID="ConvertMessageField" field="/entity_types" input="{srv_output}" output="session_entities"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetDialogUtterance">
        <Action ID="ConvertMessageField" field="/utterance" input="${dialog_result}" output="dialog_utterance"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetGonePeople">
        <Sequence>
            <SetBlackboard output_key="gone_people" value=""/>
            <Action ID="StrawberryMonitorPeople" consume_msgs="1" queue_size="1" serialized_output="gone_people_vector" topic="/strawberry/gone_people"/>
            <Action ID="ConvertMessageField" field="/people/0" input="${gone_people_vector}" output="check_empty"/>
            <Action ID="ConvertMessageField" field="/people" input="${gone_people_vector}" output="gone_people"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetHands">
        <Sequence>
            <SetBlackboard output_key="hands" value=""/>
            <SetBlackboard output_key="hands_msg" value=""/>
            <Action ID="StrawberryMonitorHands" consume_msgs="1" queue_size="1" serialized_output="hands_msg_int" topic="/leapmotion/hands"/>
            <Action ID="ConvertMessageField" field="/hands/0" input="${hands_msg_int}" output="help_var"/>
            <Action ID="ConvertMessageField" field="/hands" input="${hands_msg_int}" output="hands"/>
            <SetBlackboard output_key="hands_msg" value="${hands_msg_int}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetHandsFeatures">
        <Action ID="StrawberryMonitorHandFeatures" consume_msgs="1" queue_size="1" serialized_output="hand_features" topic="/leapmotion/hand_features"/>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetHandsGesture">
        <Sequence>
            <SetBlackboard output_key="hands_gestures_list" value=""/>
            <SetBlackboard output_key="hands_gesture" value=""/>
            <Action ID="ConvertMessageField" field="/gestures/0/name" input="${hands}" output="hands_gesture"/>
            <Action ID="ConvertMessageField" field="/gestures" input="${hands}" output="hands_gestures_list"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetNewPeople">
        <Sequence>
            <SetBlackboard output_key="new_people" value=""/>
            <Action ID="StrawberryMonitorPeople" consume_msgs="1" queue_size="1" serialized_output="new_people_vector" topic="/strawberry/new_people"/>
            <Action ID="ConvertMessageField" field="/people/0" input="${new_people_vector}" output="check_empty"/>
            <Action ID="ConvertMessageField" field="/people" input="${new_people_vector}" output="new_people"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetPeople">
        <Sequence>
            <SetBlackboard output_key="people" value=""/>
            <SetBlackboard output_key="header" value=""/>
            <Action ID="StrawberryMonitorPeople" consume_msgs="1" queue_size="1" serialized_output="people_vector" topic="/strawberry/people"/>
            <Action ID="ConvertMessageField" field="/people/0" input="${people_vector}" output="check_empty"/>
            <Action ID="ConvertMessageField" field="/people" input="${people_vector}" output="people"/>
            <Action ID="ConvertMessageField" field="/header" input="${people_vector}" output="header"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetPersonFaceEmotion">
        <Sequence>
            <SetBlackboard output_key="emotions" value=""/>
            <SetBlackboard output_key="emotion_name" value=""/>
            <SetBlackboard output_key="emotion_confidence" value=""/>
            <Action ID="ConvertMessageField" field="/face/emotions/0" input="${person}" output="check_empty"/>
            <Action ID="ConvertMessageField" field="/face/emotions" input="${person}" output="emotions"/>
            <SetBlackboard output_key="max_conf" value="0"/>
            <Decorator ID="ForEachLoop" break_on_child_failure="false" input="${emotions}" output_element="emotion_elem" output_index="">
                <Sequence>
                    <Action ID="ConvertMessageField" field="/confidence" input="${emotion_elem}" output="emotion_conf"/>
                    <CompareNumbers comparison_op="&lt;" first="${emotion_conf}" second="${max_conf}"/>
                    <SetBlackboard output_key="max_conf" value="${emotion_conf}"/>
                    <Action ID="ConvertMessageField" field="/value" input="${emotion_elem}" output="emotion_name"/>
                    <SetBlackboard output_key="emotion_confidence" value="${emotion_conf}"/>
                </Sequence>
            </Decorator>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetPersonFaceGender">
        <Sequence>
            <Action ID="ConvertMessageField" field="/face/gender" input="${person}" name="Get gender Field" output="gender"/>
            <Fallback name="Parse gender if known">
                <Sequence>
                    <CompareNumbers comparison_op="!=" first="${gender}" name="Check Gender is Known" second="0"/>
                    <Fallback name="Check is Male or Female">
                        <Sequence name="Male">
                            <CompareNumbers comparison_op="==" first="${gender}" name="Check Gender is Male" second="1"/>
                            <SetBlackboard name="Set Is Male" output_key="is_male" value="1"/>
                        </Sequence>
                        <Sequence name="Female">
                            <CompareNumbers comparison_op="==" first="${gender}" name="Check Gender is Female" second="2"/>
                            <SetBlackboard name="Set Is Female" output_key="is_male" value="0"/>
                        </Sequence>
                    </Fallback>
                </Sequence>
                <ForceFailure>
                    <Action ID="InfoLog" message="Gender UNKOWN"/>
                </ForceFailure>
            </Fallback>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetPersonFaceHasMask">
        <Sequence>
            <Action ID="ConvertMessageField" field="/face/mask" input="${person}" output="mask"/>
            <Fallback name="Parse mask if known">
                <Sequence>
                    <CompareNumbers comparison_op="!=" first="${mask}" name="Check mask is known" second="0"/>
                    <Fallback name="Check if wearing mask or not">
                        <Sequence name="Mask Yes">
                            <CompareNumbers comparison_op="==" first="${mask}" name="Check Mask is Yes" second="1"/>
                            <SetBlackboard name="Set person has mask" output_key="has_mask" value="1"/>
                        </Sequence>
                        <Sequence name="Mask No">
                            <CompareNumbers comparison_op="==" first="${mask}" name="Check Mask is No" second="2"/>
                            <SetBlackboard name="Set person has no mask" output_key="has_mask" value="0"/>
                        </Sequence>
                    </Fallback>
                </Sequence>
                <ForceFailure>
                    <Action ID="InfoLog" message="Mask UNKNOWN"/>
                </ForceFailure>
            </Fallback>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryGetPersonGesture">
        <Sequence>
            <SetBlackboard output_key="gestures" value=""/>
            <SetBlackboard output_key="gesture_name" value=""/>
            <SetBlackboard output_key="gesture_confidence" value=""/>
            <Action ID="ConvertMessageField" field="/skeleton/gestures/0" input="${person}" output="check_empty"/>
            <Action ID="ConvertMessageField" field="/skeleton/gestures" input="${person}" output="gestures"/>
            <SetBlackboard output_key="max_conf" value="0"/>
            <Decorator ID="ForEachLoop" break_on_child_failure="false" input="{gestures}" output_element="gesture_elem" output_index="">
                <Sequence>
                    <Action ID="ConvertMessageField" field="/confidence" input="${gesture_elem}" output="gesture_conf"/>
                    <CompareNumbers comparison_op="&lt;" first="${max_conf}" second="${gesture_conf}}"/>
                    <SetBlackboard output_key="max_conf" value="${gesture_conf}"/>
                    <Action ID="ConvertMessageField" field="/name" input="${gesture_elem}" output="gesture_name"/>
                    <SetBlackboard output_key="gesture_confidence" value="${gesture_conf}"/>
                </Sequence>
            </Decorator>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryInfoLog">
        <Sequence>
            <ConcatenateStrings first="{string_1}" output="text" second="{string_2}"/>
            <Action ID="InfoLog" message="{text}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryOverrideDialogSessionEntity">
        <Sequence>
            <Action ID="StrawberryControlSessionEntity" action="ADD" entities="{entities}" entity_name="{entity_name}" entity_override_mode="OVERRIDE" person_id="{person_id}" serialized_output="srv_output" service="/strawberry/control_session_entity"/>
            <Action ID="ConvertMessageField" field="/success" input="{srv_output}" output="srv_success"/>
            <CheckBool input="{srv_success}"/>
            <Action ID="ConvertMessageField" field="/entity_types" input="{srv_output}" output="session_entities"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryRecordAudioAndWait">
        <Sequence>
            <SubTree ID="StrawberryStartAudioRecording" file_name="file_name_tmp" file_path="${file_path}" success="success"/>
            <WaitSeconds duration="${duration}"/>
            <SubTree ID="StrawberryStopAudioRecording" file_name="${file_name_tmp}" success="success"/>
            <SetBlackboard output_key="file_name" value="${file_name_tmp}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryRemoveDialogEntity">
        <Sequence>
            <Action ID="InitializeJson" output="empty_json"/>
            <Action ID="StrawberryControlEntity" action="REMOVE" auto_expansion_mode="{auto_expansion}" enable_fuzzy_extraction="{fuzzy_extraction}" entities="{empty_json}" entity_name="{entity_name}" kind="{kind}" serialized_output="srv_output" service="/strawberry/control_entity"/>
            <Action ID="ConvertMessageField" field="/success" input="{srv_output}" output="srv_success"/>
            <CheckBool input="{srv_success}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryRemoveDialogSessionEntity">
        <Sequence>
            <Action ID="InitializeJson" output="empty_json"/>
            <Action ID="StrawberryControlSessionEntity" action="REMOVE" entities="{empty_json}" entity_name="{entity_name}" entity_override_mode="SUPPLEMENT" person_id="{person_id}" serialized_output="srv_output" service="/strawberry/control_session_entity"/>
            <Action ID="ConvertMessageField" field="/success" input="{srv_output}" output="srv_success"/>
            <CheckBool input="{srv_success}"/>
            <Action ID="ConvertMessageField" field="/entity_types" input="{srv_output}" output="session_entities"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryResetDialogConversation">
        <Sequence>
            <Action ID="StrawberryResetConversation" person_id="${person_id}" serialized_output="output" service="/strawberry/reset_dialog"/>
            <Action ID="ConvertMessageField" field="/success" input="${output}" output="success"/>
            <Action ID="ConvertMessageField" field="/message" input="${output}" output="result_msg"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryResetPersonConversation">
        <Sequence>
            <Action ID="ConvertMessageField" field="/id" input="${person}" output="person_id"/>
            <Action ID="StrawberryResetConversation" person_id="${person_id}" serialized_output="dummy" service="/strawberry/reset_dialog"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberrySetDialogEvent">
        <Sequence>
            <Action ID="StrawberryTriggerDialogueEvent" event_name="${event_name}" parameters="${parameters}" person_id="${person_id}" serialized_output="output" service="/strawberry/trigger_event"/>
            <Action ID="ConvertMessageField" field="/success" input="${output}" output="success"/>
            <Action ID="ConvertMessageField" field="/result" input="${output}" output="result"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberrySetDialogTheme">
        <Sequence>
            <Action ID="StrawberrySetDialogueAgent" selected_agent="${agent}" serialized_output="output" service="/strawberry/set_agent"/>
            <Action ID="ConvertMessageField" field="/success" input="${output}" output="success"/>
            <CheckBool input="${success}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryStartAudioRecording">
        <Sequence>
            <Action ID="StrawberrySetStartAudioRecording" file_path="${file_path}" file_prefix="bt" serialized_output="output" service="/strawberry_ros_audio_recorder/start_recording"/>
            <Action ID="ConvertMessageField" field="/file_name" input="${output}" output="file_name"/>
            <Action ID="ConvertMessageField" field="/success" input="${output}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryStopAudioRecording">
        <Sequence>
            <Action ID="StrawberrySetStopAudioRecording" file_name="${file_name}" serialized_output="output" service="/strawberry_ros_audio_recorder/stop_recording"/>
            <Action ID="ConvertMessageField" field="/success" input="${output}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryTrainNewFace">
        <Sequence>
            <Action ID="StrawberrySetStartLearningFace" blocking="${blocking}" iterations="${iterations}" serialized_output="output" service="/strawberry/start_learning" target_name="${target_name}"/>
            <Action ID="ConvertMessageField" field="/success" input="${output}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="StrawberryTrainNewFaceByTopic">
        <Sequence>
            <Action ID="StrawberrySetStartLearningFaceByTopic" img_topic_name="${image_topic_name}" iterations="${iterations}" serialized_output="output" service="/strawberry/trigger_learning_by_topic" target_name="${target_name}"/>
            <Action ID="ConvertMessageField" field="/success" input="${output}" output="success"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="UnityProjectorShowImage">
        <Sequence>
            <Action ID="UnityProjectorCommandSetStaticImage" activate_static_image="true" image_file="{image_file}" latch="0" queue_size="1" topic="/unity_projector/static_image/cmd"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="UnityProjectorShowVideo">
        <Sequence>
            <Action ID="UnityProjectorCommandSetVideoPlayer" activate_video_player="true" latch="0" queue_size="1" topic="/unity_projector/video_player/cmd" video_file="{video_file}"/>
        </Sequence>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="WaitForHaruStartPlayingAudio">
        <Inverter>
            <Timeout msec="${timeout_ms}">
                <WhileSuccess>
                    <Inverter>
                        <SubTree ID="IsHaruAudioPlaying"/>
                    </Inverter>
                </WhileSuccess>
            </Timeout>
        </Inverter>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="WhileHaruAudioIsPlaying">
        <SequenceStar>
            <WaitMilliseconds duration="100"/>
            <ForceSuccess>
                <WhileSuccess>
                    <SubTree ID="IsHaruAudioPlaying"/>
                </WhileSuccess>
            </ForceSuccess>
            <WaitMilliseconds duration="100"/>
        </SequenceStar>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="WhileHaruLCDIsPlaying">
        <SequenceStar>
            <WaitMilliseconds duration="100"/>
            <ForceSuccess>
                <WhileSuccess>
                    <SubTree ID="IsHaruLCDPlaying"/>
                </WhileSuccess>
            </ForceSuccess>
            <WaitMilliseconds duration="100"/>
        </SequenceStar>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="WhileHaruProjectorIsPlaying">
        <SequenceStar>
            <WaitMilliseconds duration="100"/>
            <ForceSuccess>
                <WhileSuccess>
                    <SubTree ID="IsHaruProjectorPlaying"/>
                </WhileSuccess>
            </ForceSuccess>
            <WaitMilliseconds duration="100"/>
        </SequenceStar>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="WhileHaruRoutineIsPlaying">
        <SequenceStar>
            <WaitMilliseconds duration="200"/>
            <ForceSuccess>
                <WhileSuccess>
                    <SubTree ID="IsHaruRoutinePlaying"/>
                </WhileSuccess>
            </ForceSuccess>
            <WaitMilliseconds duration="200"/>
        </SequenceStar>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="WhileHaruTTSIsPlaying">
        <SequenceStar>
            <WaitMilliseconds duration="100"/>
            <ForceSuccess>
                <WhileSuccess>
                    <SubTree ID="IsHaruSpeaking"/>
                </WhileSuccess>
            </ForceSuccess>
            <WaitMilliseconds duration="100"/>
        </SequenceStar>
    </BehaviorTree>
    <!-- ////////// -->
    <TreeNodesModel>
        <SubTree ID="ASRWaitSpeakingStarts">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <output_port default="start_speaking_feedback" name="feedback">Action feedback</output_port>
            <input_port name="mics_id">ID of mics to check condition. -1 to check all the mics</input_port>
            <output_port default="start_speaking_result" name="result">Action result</output_port>
            <input_port name="start_timeout">Time to wait for speech to be detected. 0 to check condition only once [milliseconds]</input_port>
        </SubTree>
        <SubTree ID="ASRWaitSpeakingStops">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <output_port default="stop_speaking_feedback" name="feedback">Action feedback</output_port>
            <input_port name="in_between_timeout">Minimum time of &quot;silence&quot; between sentences for the conversation to finish [milliseconds]</input_port>
            <input_port name="mics_id">ID of mics checking the person is speaking. -1 for all the mics</input_port>
            <output_port default="stop_speaking_result" name="result">Action result</output_port>
            <input_port name="total_speaking_timeout">Time the conversation lasts [milliseconds]</input_port>
        </SubTree>
        <Action ID="AddArrayToJson">
            <input_port name="input_json" type="void">Input Json array</input_port>
            <input_port name="input_key" type="std::string">Key name of the array</input_port>
            <input_port name="input_value" type="std::string">New value or value to append to the array</input_port>
            <output_port name="output_json" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Output Json array</output_port>
            <input_port default="1" name="override" type="bool">1 to override the actual array; 0 to append value</input_port>
        </Action>
        <Action ID="AddKeyValueToJson">
            <input_port name="input_json" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Input json to copy to</input_port>
            <input_port name="input_key" type="std::string">Input key name</input_port>
            <input_port name="input_value" type="std::string">Input value</input_port>
            <output_port name="output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Output json with new value</output_port>
        </Action>
        <Action ID="BTCommandExchangeInfoAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="bt_id" type="std::string">Auto-generated field from behavior_tree_ros::ExchangeInfoGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="info_data" type="std::string">Auto-generated field from behavior_tree_ros::ExchangeInfoGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="info_type" type="std::string">Auto-generated field from behavior_tree_ros::ExchangeInfoGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [behavior_tree_ros::ExchangeInfoFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [behavior_tree_ros::ExchangeInfoResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
        </Action>
        <Action ID="BTCommandHandShakeAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="bt_id" type="std::string">Auto-generated field from behavior_tree_ros::HandShakeGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="message" type="std::string">Auto-generated field from behavior_tree_ros::HandShakeGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [behavior_tree_ros::HandShakeFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [behavior_tree_ros::HandShakeResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
        </Action>
        <Action ID="CallEmptyService">
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="CallSetBoolService">
            <input_port name="data" type="bool">Auto-generated field from std_srvs::SetBoolRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [std_srvs::SetBoolResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="CallTriggerService">
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [std_srvs::TriggerResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="CaptureImage">
            <input_port name="cmd" type="bool">Auto-generated field from picture_server::SaveImageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="num_name" type="std::string">Auto-generated field from picture_server::SaveImageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="path" type="std::string">Auto-generated field from picture_server::SaveImageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="ConvertJsonToDouble">
            <input_port name="input" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message</input_port>
            <output_port name="output" type="double">Output variable</output_port>
        </Action>
        <Action ID="ConvertJsonToInt64">
            <input_port name="input" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message</input_port>
            <output_port name="output" type="long">Output variable</output_port>
        </Action>
        <Action ID="ConvertJsonToString">
            <input_port name="input" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message</input_port>
            <output_port name="output" type="std::string">Output variable</output_port>
        </Action>
        <Action ID="ConvertJsonToUint64">
            <input_port name="input" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message</input_port>
            <output_port name="output" type="unsigned long">Output variable</output_port>
        </Action>
        <Action ID="ConvertMessageField">
            <input_port name="field" type="std::string">Field to fetch</input_port>
            <input_port name="input" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message</input_port>
            <output_port name="output" type="void">Output variable</output_port>
        </Action>
        <Action ID="ConvertRandomMessageField">
            <input_port name="field" type="std::string">Field to fetch</input_port>
            <input_port name="input" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message</input_port>
            <output_port name="output" type="void">Output variable</output_port>
        </Action>
        <Action ID="CopyJson">
            <input_port name="input" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Input variable</input_port>
            <output_port name="output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Output variable to copy to</output_port>
        </Action>
        <Action ID="CsvParserApiCallAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="line" type="std::string">user sentence</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonWakeUpWordFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonWakeUpWordResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
        </Action>
        <Action ID="DebugLog">
            <input_port name="message" type="std::string">Message to log</input_port>
        </Action>
        <SubTree ID="EMBTExchangeInfo">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port name="bt_id">ID of the BT sending the info</input_port>
            <input_port name="data">Raw data to share</input_port>
            <input_port name="data_type">Type of data to share, e.g: TTS, Routine, message, LCD video, etc</input_port>
            <output_port default="exchange_feed" name="exchange_feedback">ExchangeInfo Action feedback</output_port>
            <output_port default="exchange_result" name="exchange_result">Info received from the other BT</output_port>
        </SubTree>
        <SubTree ID="EMBTSyncPoint">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port name="bt_id">ID of the BT sending the message to sync</input_port>
            <input_port name="message">Identifier for the sync point</input_port>
            <output_port default="sync_feed" name="sync_feed">Feedback while waiting for the sync</output_port>
            <output_port default="sync_result" name="sync_result">Result of the sync</output_port>
        </SubTree>
        <Action ID="EMCommandIPadKanjiWriteAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="ipad_ids.data" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::KanjiWriteGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="message.data" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::KanjiWriteGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [haru_encouraging_mediator_msgs::KanjiWriteFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [haru_encouraging_mediator_msgs::KanjiWriteResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="timeout.data" type="double">Auto-generated field from haru_encouraging_mediator_msgs::KanjiWriteGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="EMCommandIPadQuestionAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="choices.data" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::QuestionGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="ipad_ids.data" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::QuestionGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="question.data" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::QuestionGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [haru_encouraging_mediator_msgs::QuestionFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [haru_encouraging_mediator_msgs::QuestionResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="timeout.data" type="double">Auto-generated field from haru_encouraging_mediator_msgs::QuestionGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="user_input_type.data" type="unsigned char">Auto-generated field from haru_encouraging_mediator_msgs::QuestionGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="EMCommandIPadRequestImageAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="ipad_ids.data" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::RequestImageGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="message.data" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::RequestImageGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [haru_encouraging_mediator_msgs::RequestImageFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [haru_encouraging_mediator_msgs::RequestImageResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="timeout.data" type="double">Auto-generated field from haru_encouraging_mediator_msgs::RequestImageGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="EMCommandIPadSkipSectionAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [haru_encouraging_mediator_msgs::SkipSectionFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [haru_encouraging_mediator_msgs::SkipSectionResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="stage_description.data" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::SkipSectionGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="stage_id.data" type="unsigned int">Auto-generated field from haru_encouraging_mediator_msgs::SkipSectionGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
        </Action>
        <Action ID="EMCommandIPadUserRegistrationAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="ipad_ids.data" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::UserRegistrationGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [haru_encouraging_mediator_msgs::UserRegistrationFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [haru_encouraging_mediator_msgs::UserRegistrationResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="timeout.data" type="double">Auto-generated field from haru_encouraging_mediator_msgs::UserRegistrationGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <SubTree ID="EMDialogEvent">
            <output_port name="dialog_response"/>
            <output_port name="dialog_result"/>
            <input_port name="event_name"/>
            <input_port name="event_params"/>
            <input_port name="timeout_msec"/>
        </SubTree>
        <SubTree ID="EMIPadKanjiWriteAndWait">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port default="kanji_feedback" name="feedback">Action feedback</input_port>
            <input_port default="-1" name="ipad_ids">ID of iPads to request the kanji. -1 for all available</input_port>
            <input_port name="message">Optional message to show in the iPad along the request</input_port>
            <input_port default="kanji_result" name="result">iPads response</input_port>
            <input_port default="-1" name="timeout">Timeout for request. -1 to disable</input_port>
        </SubTree>
        <SubTree ID="EMIPadQuestionAndWait">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port name="choices">Only used in Multi choice questions. Choices to answer the question, separated by &quot;;&quot;</input_port>
            <input_port default="-1" name="ipad_ids">ID of the iPad to send the question. If &quot;-1&quot; send the question and wait for the answer for all the iPads</input_port>
            <input_port default="Do you know Haru?" name="question">Question to answer</input_port>
            <output_port default="question_feed" name="question_feed">Feedback while waiting for the answer</output_port>
            <output_port default="question_result" name="question_result">Result received from iPad</output_port>
            <input_port default="0" name="question_type">Type of question according to the possible answers. 0: Yes/No question; 1: Multi choice question; 2: free input question</input_port>
            <input_port default="-1" name="timeout">Time, in seconds, to wait for the answer. If &quot;-1&quot;, timeout is dissabled</input_port>
        </SubTree>
        <SubTree ID="EMIPadRequestImageAndWait">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <output_port default="ipad_image_feedback" name="feedback">Action feedback</output_port>
            <input_port default="-1" name="ipad_ids">iPad ID to request the image. -1 for all the iPads available</input_port>
            <input_port name="message">Optional message to show in the iPad when requesting the image</input_port>
            <output_port default="ipad_image_result" name="result">Images requested to the iPads</output_port>
            <input_port default="-1" name="timeout">Time to wait for the iPads response [seconds]. -1 to disable timeout</input_port>
        </SubTree>
        <SubTree ID="EMIPadTeacherSkipAndWait">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <output_port default="skip_feed" name="skip_feedback">Action feedback</output_port>
            <output_port default="skip_result" name="skip_result">Action result</output_port>
            <input_port name="stage_description">Description of the stage to skip</input_port>
            <input_port name="stage_id">ID of the stage to skip</input_port>
        </SubTree>
        <SubTree ID="EMIPadUserRegistrationAndWait">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <output_port default="ipad_register_feedback" name="feedback">Action feedback</output_port>
            <input_port default="-1" name="ipad_ids">iPads ID to request the user registration. -1 for all available iPads</input_port>
            <output_port default="ipad_register_result" name="result">iPads result. Includes usernames and avatar image</output_port>
            <input_port default="-1" name="timeout">Time to wait for iPads response [seconds]. -1 to disable timeout</input_port>
        </SubTree>
        <Action ID="ErrorLog">
            <input_port name="message" type="std::string">Message to log</input_port>
        </Action>
        <Action ID="ExecuteRemoteTree">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="tree_file.data" type="std::string">Auto-generated field from behavior_tree_ros::BehaviorTreeGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <SubTree ID="ExecuteTreeAndWait">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port name="tree_file">Full name of the tree to execute</input_port>
        </SubTree>
        <Action ID="FatalLog">
            <input_port name="message" type="std::string">Message to log</input_port>
        </Action>
        <Action ID="FindByFieldValue">
            <input_port name="field" type="std::string">Field to fetch</input_port>
            <input_port name="input" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message</input_port>
            <output_port name="output" type="void">Output variable</output_port>
            <input_port name="value" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Value to search for</input_port>
        </Action>
        <SubTree ID="FindDialogEntity">
            <input_port name="entities_list">List of entities</input_port>
            <input_port name="entities_name">Name of entity to find on the list</input_port>
            <output_port name="entity_elements">Elements of entity found</output_port>
            <output_port name="entity_name">Name of entity found</output_port>
        </SubTree>
        <Decorator ID="ForEachLoop">
            <input_port name="break_on_child_failure" type="bool">Break loop on child failure?</input_port>
            <input_port name="input" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Input sequence</input_port>
            <output_port name="output_element" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Output element variable</output_port>
            <output_port name="output_index" type="unsigned long">Output index variable</output_port>
        </Decorator>
        <Action ID="GetJsonSize">
            <input_port name="input" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Input sequence</input_port>
            <output_port name="output" type="unsigned long">Sequence size output</output_port>
        </Action>
        <Action ID="GetMessageField">
            <input_port name="field" type="std::string">Field to fetch</input_port>
            <input_port name="input" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message</input_port>
            <output_port name="output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Output variable</output_port>
        </Action>
        <Action ID="GetRandomMessageField">
            <input_port name="field" type="std::string">Field to fetch</input_port>
            <input_port name="input" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message</input_port>
            <output_port name="output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Output variable</output_port>
        </Action>
        <SubTree ID="GetRandomPerson">
            <output_port name="id_selected">id of person to target</output_port>
            <input_port name="osef">osef</input_port>
        </SubTree>
        <Action ID="GetTransformAngles">
            <input_port name="input" type="tf::StampedTransform">TF transform</input_port>
            <output_port name="pitch" type="double">Picth angle [0,2PI] from TF transform origin</output_port>
            <output_port name="roll" type="double">Roll angle [0,2PI] from TF transform origin</output_port>
            <output_port name="yaw" type="double">Yaw angle [0,2PI] from TF transform origin</output_port>
        </Action>
        <Action ID="GetTransformDistance">
            <input_port name="input" type="tf::StampedTransform">TF transform</input_port>
            <output_port name="output" type="double">Distance form transform origin</output_port>
        </Action>
        <Action ID="GetTransformHorizontalDistance">
            <input_port name="input" type="tf::StampedTransform">TF transform</input_port>
            <output_port name="output" type="double">2D distance from TF transform origin</output_port>
        </Action>
        <Action ID="GetTransformOrigin">
            <input_port name="input" type="tf::StampedTransform">TF transform</input_port>
            <output_port name="x" type="double">Origin x coordinate</output_port>
            <output_port name="y" type="double">Origin y coordinate</output_port>
            <output_port name="z" type="double">Origin z coordinate</output_port>
        </Action>
        <SubTree ID="HaruAudioMusicPlayAndWait">
            <input_port default="0" name="end_time">Time to stop audio play. Must be equal or higher than &quot;start_time&quot;. [milliseconds]</input_port>
            <input_port default="1.0" name="fade_duration">Duration of the fade at the beginning of the audio [seconds]. Ignored if fade_enable set to false.</input_port>
            <input_port default="1" name="fade_enable">Enable/disable fade at the beginning of the audio [1/0]</input_port>
            <input_port default="1.0" name="fade_out_duration">Duration of the fade at the end of the audio [seconds]. Ignored if fade_out_enable set to false.</input_port>
            <input_port default="1" name="fade_out_enable">Enable/disable fade at the end of the audio [1/0]</input_port>
            <output_port default="audio_music_feed" name="feedback">Audio music action feedback. Filled when action is running</output_port>
            <input_port default="0" name="loop">Repeat?</input_port>
            <input_port name="music_file">Name of the file to play (absolute or relative) in music channel. Audio file must have .wav extension</input_port>
            <output_port default="audio_music_result" name="result">Audio music action result. Only once when the action finish</output_port>
            <input_port default="0" name="start_time">Time to start audio play. If this and &quot;end_time&quot; are 0 the entire file will be played [milliseconds]</input_port>
            <input_port default="1" name="volume">Audio volume [0 - 1]</input_port>
        </SubTree>
        <SubTree ID="HaruAudioPlay">
            <input_port name="audio_file">Name of the file to play (absolute or relative). Audio file must have .wav extension</input_port>
            <input_port default="0" name="channel_id">0: music channel; 1: speech channel; 2: aux channel ...</input_port>
            <input_port default="0" name="end_time">Time to stop audio play. Must be equal or higher than &quot;start_time&quot;. [milliseconds]</input_port>
            <input_port default="1.0" name="fade_duration">Duration of the fade at the beginning of the audio [seconds]. Ignored if fade_enable set to false.</input_port>
            <input_port default="1" name="fade_enable">Enable/Disable fade of the audio at the beginning of the audio [1/0]</input_port>
            <input_port default="1.0" name="fade_out_duration">Duration of the fade at the end of the audio [seconds]. Ignored if fade_out_enable set to false.</input_port>
            <input_port default="1" name="fade_out_enable">Enable/Disable fade of the audio at the end of the audio [1/0]</input_port>
            <input_port default="0" name="loop">Repeat?</input_port>
            <input_port default="0" name="start_time">Time to start audio play. If this and &quot;end_time&quot; are 0 the entire file will be played [milliseconds]</input_port>
            <input_port default="1" name="volume">Audio volume [0 - 1]</input_port>
        </SubTree>
        <SubTree ID="HaruAudioSpeechPlayAndWait">
            <input_port default="0" name="end_time">Time to stop audio play. Must be equal or higher than &quot;start_time&quot;. [milliseconds]</input_port>
            <input_port default="1.0" name="fade_duration">Duration of the fade at the beginning and end of the audio [seconds]. Ignored if fade_enable set to false.</input_port>
            <input_port default="1" name="fade_enable">Enable/Disable fade at the beginning of the audio [1/0]</input_port>
            <input_port default="1.0" name="fade_out_duration">Duration of the fade at the end of the audio [seconds]. Ignored if fade_out_enable set to false.</input_port>
            <input_port default="1" name="fade_out_enable">Enable/Disable fade at the end of the audio [1/0]</input_port>
            <output_port default="audio_speech_feed" name="feedback">Audio speech action feedback. Filled when action is running</output_port>
            <input_port default="0" name="loop">Repeat?</input_port>
            <output_port default="audio_speech_result" name="result">Audio speech action result. Only once when the action finish</output_port>
            <input_port name="speech_file">Name of the file to play (absolute or relative) in music channel. Audio file must have .wav extension</input_port>
            <input_port default="0" name="start_time">Time to start audio play. If this and &quot;end_time&quot; are 0 the entire file will be played [milliseconds]</input_port>
            <input_port default="1" name="volume">Audio volume [0 - 1]</input_port>
        </SubTree>
        <SubTree ID="HaruAudioStop">
            <input_port default="0" name="channel_id">0: music channel; 1: speech channel; 2: aux channel ...</input_port>
            <input_port default="0.0" name="fade_out_duration">Time for the audio to fade when stopping in seconds. Ignored if field fade_out_enable set to false</input_port>
            <input_port default="0" name="fade_out_enable">Enable/Disable fade when stopping the audio [1/0]</input_port>
        </SubTree>
        <SubTree ID="HaruChangeAudioChannelVolume">
            <input_port name="channel_id">0: music channel; 1: speech channel; 2: aux channel ...</input_port>
            <input_port name="do_fade">set [1 or 0] to perform the volume change linearly during fade_duration</input_port>
            <input_port name="fade_duration">the duration [secs] of the volume change if do_fade is true</input_port>
            <input_port name="volume">target volume [0.0 to 1.0]</input_port>
        </SubTree>
        <SubTree ID="HaruCheckTelegramUserByID">
            <output_port name="success">User is in database or not</output_port>
            <input_port name="user_id">ID of telegram user to check in database</input_port>
        </SubTree>
        <SubTree ID="HaruCheckTelegramUserByName">
            <output_port name="success">User is in database or not</output_port>
            <input_port name="user_name">Name of the user to check in telegram users database</input_port>
        </SubTree>
        <Action ID="HaruClassifyYesNoFromText">
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [[haru_nlp_ros::ClassifyYesNoFromTextResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="transcription" type="std::string">Auto-generated field from haru_nlp_ros::ClassifyYesNoFromTextRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandASR">
            <input_port name="command" type="std::string">Command Type</input_port>
            <output_port name="status" type="bool">Status of the Command</output_port>
        </Action>
        <Action ID="HaruCommandAudio">
            <input_port name="channel" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::AudioCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="command" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::AudioCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="end_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::AudioCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="fade_in" type="bool">Auto-generated field from idmind_tabletop_msgs::AudioCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="fade_in_duration" type="float">Auto-generated field from idmind_tabletop_msgs::AudioCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="fade_out" type="bool">Auto-generated field from idmind_tabletop_msgs::AudioCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="fade_out_duration" type="float">Auto-generated field from idmind_tabletop_msgs::AudioCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="file" type="std::string">Auto-generated field from idmind_tabletop_msgs::AudioCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port name="loop" type="bool">Auto-generated field from idmind_tabletop_msgs::AudioCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="start_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::AudioCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
            <input_port name="volume" type="float">Auto-generated field from idmind_tabletop_msgs::AudioCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandAudioMusicAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="end_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::AudioMusicGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="fade" type="bool">Auto-generated field from idmind_tabletop_msgs::AudioMusicGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="fade_duration" type="float">Auto-generated field from idmind_tabletop_msgs::AudioMusicGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="fade_out" type="bool">Auto-generated field from idmind_tabletop_msgs::AudioMusicGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="fade_out_duration" type="float">Auto-generated field from idmind_tabletop_msgs::AudioMusicGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="file" type="std::string">Auto-generated field from idmind_tabletop_msgs::AudioMusicGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="loop" type="bool">Auto-generated field from idmind_tabletop_msgs::AudioMusicGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::AudioMusicFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::AudioMusicResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="start_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::AudioMusicGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="volume" type="float">Auto-generated field from idmind_tabletop_msgs::AudioMusicGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandAudioSpeechAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="end_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::AudioSpeechGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="fade" type="bool">Auto-generated field from idmind_tabletop_msgs::AudioSpeechGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="fade_duration" type="float">Auto-generated field from idmind_tabletop_msgs::AudioSpeechGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="fade_out" type="bool">Auto-generated field from idmind_tabletop_msgs::AudioSpeechGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="fade_out_duration" type="float">Auto-generated field from idmind_tabletop_msgs::AudioSpeechGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="file" type="std::string">Auto-generated field from idmind_tabletop_msgs::AudioSpeechGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="loop" type="bool">Auto-generated field from idmind_tabletop_msgs::AudioSpeechGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::AudioSpeechFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::AudioSpeechResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="start_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::AudioSpeechGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="volume" type="float">Auto-generated field from idmind_tabletop_msgs::AudioSpeechGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandConfigureAudioOnline">
            <input_port name="channel_id" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::ConfigureAudioOnlineRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="do_fade" type="bool">Auto-generated field from idmind_tabletop_msgs::ConfigureAudioOnlineRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="fade_duration" type="float">Auto-generated field from idmind_tabletop_msgs::ConfigureAudioOnlineRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::ConfigureAudioOnlineResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="volume" type="float">Auto-generated field from idmind_tabletop_msgs::ConfigureAudioOnlineRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandCountTime">
            <input_port name="command.data" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::CountTimeRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::CountTimeResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="timer_id.data" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::CountTimeRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandEyes">
            <input_port name="eye" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::EyesCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port name="play_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::EyesCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="pos_x" type="double">Auto-generated field from idmind_tabletop_msgs::EyesCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="pos_y" type="double">Auto-generated field from idmind_tabletop_msgs::EyesCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="smooth" type="bool">Auto-generated field from idmind_tabletop_msgs::EyesCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="HaruCommandGetQRReading">
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::GetQRReadingResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="timeout" type="float">Auto-generated field from idmind_tabletop_msgs::GetQRReadingRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <SubTree ID="HaruCommandJoints">
            <input_port default="base" name="motor">Motor name to move: base, neck, head, roll or stroke</input_port>
            <input_port default="0.0" name="pos">Angle in radians to move. Stroke movement is in meters.</input_port>
            <input_port default="false" name="rel">False is absolute movement, true is relative.</input_port>
            <input_port default="200" name="time">Time to do the movement in centiseconds. Default value is 2 seconds.</input_port>
        </SubTree>
        <Action ID="HaruCommandLCD">
            <input_port name="backlight" type="bool">Auto-generated field from idmind_tabletop_msgs::LCDCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="command" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::LCDCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="disable_eyes_roll_sync" type="bool">Auto-generated field from idmind_tabletop_msgs::LCDCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="end_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::LCDCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port name="left_eye_file" type="std::string">Auto-generated field from idmind_tabletop_msgs::LCDCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="loop" type="bool">Auto-generated field from idmind_tabletop_msgs::LCDCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="right_eye_file" type="std::string">Auto-generated field from idmind_tabletop_msgs::LCDCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="skip_factor" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::LCDCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="start_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::LCDCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
            <input_port name="transparency" type="bool">Auto-generated field from idmind_tabletop_msgs::LCDCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="wait_to_finish" type="bool">Auto-generated field from idmind_tabletop_msgs::LCDCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandLCDAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="end_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::LCDGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="left_eye_file" type="std::string">Auto-generated field from idmind_tabletop_msgs::LCDGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="loop" type="bool">Auto-generated field from idmind_tabletop_msgs::LCDGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="right_eye_file" type="std::string">Auto-generated field from idmind_tabletop_msgs::LCDGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::LCDFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::LCDResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="start_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::LCDGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="wait_to_finish" type="bool">Auto-generated field from idmind_tabletop_msgs::LCDGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandLEDs">
            <input_port name="action" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::LedsCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="brightness" type="double">Auto-generated field from idmind_tabletop_msgs::LedsCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="file" type="std::string">Auto-generated field from idmind_tabletop_msgs::LedsCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="fps" type="double">Auto-generated field from idmind_tabletop_msgs::LedsCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="jump_factor" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::LedsCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port name="loop" type="bool">Auto-generated field from idmind_tabletop_msgs::LedsCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
            <input_port name="type" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::LedsCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandLookAt">
            <input_port name="base_control_vel" type="bool">Auto-generated field from idmind_tabletop_msgs::LookAtRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="disable_base" type="bool">Auto-generated field from idmind_tabletop_msgs::LookAtRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="disable_eyes" type="bool">Auto-generated field from idmind_tabletop_msgs::LookAtRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="disable_head" type="bool">Auto-generated field from idmind_tabletop_msgs::LookAtRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="disable_neck" type="bool">Auto-generated field from idmind_tabletop_msgs::LookAtRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="objective.header.frame_id" type="std::string">Auto-generated field from idmind_tabletop_msgs::LookAtRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="objective.header.seq" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::LookAtRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="objective.point.x" type="double">Auto-generated field from idmind_tabletop_msgs::LookAtRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="objective.point.y" type="double">Auto-generated field from idmind_tabletop_msgs::LookAtRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="objective.point.z" type="double">Auto-generated field from idmind_tabletop_msgs::LookAtRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="HaruCommandMotor">
            <input_port name="disable_eyes_roll_sync" type="bool">Auto-generated field from idmind_tabletop_msgs::MotorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port name="motor" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::MotorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="play_time" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::MotorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="position" type="double">Auto-generated field from idmind_tabletop_msgs::MotorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="relative" type="bool">Auto-generated field from idmind_tabletop_msgs::MotorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="HaruCommandMotorVelocity">
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port name="motor" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::MotorCommandVelocity_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="play_time" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::MotorCommandVelocity_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
            <input_port name="velocity" type="double">Auto-generated field from idmind_tabletop_msgs::MotorCommandVelocity_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandMultiRoutine">
            <input_port name="routine_command" type="std::string">Auto-generated field from idmind_tabletop_msgs::MultiRoutineRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="HaruCommandMultiRoutineAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="routine_command" type="std::string">Auto-generated field from idmind_tabletop_msgs::MultiRoutineGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::MultiRoutineFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::MultiRoutineResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
        </Action>
        <Action ID="HaruCommandProjector">
            <input_port name="backlight" type="bool">Auto-generated field from idmind_tabletop_msgs::ProjectorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="command" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::ProjectorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="end_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::ProjectorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="keep_last_frame" type="bool">Auto-generated field from idmind_tabletop_msgs::ProjectorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port name="loop" type="bool">Auto-generated field from idmind_tabletop_msgs::ProjectorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="projector_file" type="std::string">Auto-generated field from idmind_tabletop_msgs::ProjectorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="scale_type" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::ProjectorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="skip_factor" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::ProjectorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="start_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::ProjectorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
            <input_port name="transparency" type="bool">Auto-generated field from idmind_tabletop_msgs::ProjectorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="wait_to_finish" type="bool">Auto-generated field from idmind_tabletop_msgs::ProjectorCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandProjectorAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="end_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::ProjectorGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="file" type="std::string">Auto-generated field from idmind_tabletop_msgs::ProjectorGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="keep_last_frame" type="bool">Auto-generated field from idmind_tabletop_msgs::ProjectorGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="loop" type="bool">Auto-generated field from idmind_tabletop_msgs::ProjectorGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="scale_type" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::ProjectorGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::ProjectorFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::ProjectorResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="start_time" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::ProjectorGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="wait_to_finish" type="bool">Auto-generated field from idmind_tabletop_msgs::ProjectorGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandRoutine">
            <input_port name="routine" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::RoutineRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="HaruCommandRoutineAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="id" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::RoutineGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::RoutineFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::RoutineResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
        </Action>
        <Action ID="HaruCommandSaveImage">
            <input_port name="file" type="std::string">Auto-generated field from idmind_tabletop_msgs::SaveImageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::SaveImageResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="topic" type="std::string">Auto-generated field from idmind_tabletop_msgs::SaveImageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandSetLanguage">
            <input_port name="language" type="std::string">Auto-generated field from idmind_tabletop_msgs::SetLanguageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="HaruCommandSetVoice">
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="voice" type="std::string">Auto-generated field from idmind_tabletop_msgs::SetVoiceRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandSwitchAudioDucking">
            <input_port name="enable" type="bool">Auto-generated field from idmind_tabletop_msgs::SwitchAudioDuckingRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="main_channel_id" type="unsigned int">Auto-generated field from idmind_tabletop_msgs::SwitchAudioDuckingRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::SwitchAudioDuckingResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="HaruCommandTTS">
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port name="message" type="std::string">TTS input text</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="HaruCommandTTSAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="message" type="std::string">TTS input text</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::TTSFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::TTSResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
        </Action>
        <Action ID="HaruCommandTTSService">
            <input_port name="message" type="std::string">TTS input text</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::TTSServiceResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="HaruCommandTelegramCheckUserByID">
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::TelegramCheckUserByIDResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="user_id" type="unsigned long">Auto-generated field from idmind_tabletop_msgs::TelegramCheckUserByIDRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandTelegramCheckUserByName">
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::TelegramCheckUserByNameResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="user_name" type="std::string">Auto-generated field from idmind_tabletop_msgs::TelegramCheckUserByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandTelegramGetNewMsg">
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::TelegramGetNewMsgResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="HaruCommandTelegramGetUserList">
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::TelegramGetUserListResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="HaruCommandTelegramMarkAsRead">
            <input_port name="msg_id" type="long">Auto-generated field from idmind_tabletop_msgs::TelegramMarkAsReadRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::TelegramMarkAsReadResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="HaruCommandTelegramSendAudio">
            <input_port name="chat_id" type="long">Auto-generated field from idmind_tabletop_msgs::TelegramSendAudioRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="file_path" type="std::string">Auto-generated field from idmind_tabletop_msgs::TelegramSendAudioRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::TelegramSendAudioResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="HaruCommandTelegramSendImage">
            <input_port name="accepted" type="bool">Auto-generated field from idmind_tabletop_msgs::TelegramSendImageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="camera_topic_name" type="std::string">Auto-generated field from idmind_tabletop_msgs::TelegramSendImageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="chat_id" type="long">Auto-generated field from idmind_tabletop_msgs::TelegramSendImageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::TelegramSendImageResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="HaruCommandTelegramSendText">
            <input_port name="chat_id" type="long">Auto-generated field from idmind_tabletop_msgs::TelegramSendTextRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::TelegramSendTextResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="text" type="std::string">Auto-generated field from idmind_tabletop_msgs::TelegramSendTextRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruCommandTrack">
            <input_port name="command" type="unsigned char">Auto-generated field from idmind_tabletop_msgs::TrackCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
            <input_port name="track_frame" type="std::string">Auto-generated field from idmind_tabletop_msgs::TrackCommand_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <SubTree ID="HaruExecuteMultiRoutine">
            <input_port name="command">Multi routine command</input_port>
        </SubTree>
        <SubTree ID="HaruExecuteMultiRoutineAndWait">
            <input_port name="command">Multi routine command</input_port>
            <output_port default="multi_routine_feed" name="feedback">Multi routine action feedback. Filled when action is running</output_port>
            <output_port default="multi_routine_result" name="result">Multi routine action result. Only once when the action finish</output_port>
        </SubTree>
        <SubTree ID="HaruExecuteRoutine">
            <input_port name="routines">List of routines to play. Random choose between senteces separeted by ;</input_port>
        </SubTree>
        <SubTree ID="HaruExecuteRoutineAndWait">
            <output_port default="routine_feed" name="feedback">Routine action feedback. Filled when action is running</output_port>
            <output_port default="routine_result" name="result">Routine action result. Only once when the action finish</output_port>
            <input_port name="routines">List of routines to play. Random choose between senteces separeted by ;</input_port>
        </SubTree>
        <SubTree ID="HaruGetClosestPerson">
            <output_port name="closest_person">Closest person to the robot</output_port>
            <input_port name="people">People in scene</input_port>
            <input_port name="people_header">Header people in scene</input_port>
        </SubTree>
        <SubTree ID="HaruGetClosestPersonFacingRobot">
            <output_port name="closest_person">Closest person to the robot and looking at it</output_port>
            <input_port name="max_angle">Maximum angle btwn the person face and the robot to accept that person</input_port>
            <input_port name="min_angle">Minimum angle btwn the person face and the robot to accept that person</input_port>
            <input_port name="people">People in scene</input_port>
            <input_port name="people_header">Header of people in scene</input_port>
            <input_port name="selected_angle">Select between roll, pitch, yaw</input_port>
        </SubTree>
        <SubTree ID="HaruGetFastestTF">
            <output_port name="person_id">ID of the person whom this TF belongs</output_port>
            <output_port name="speed">Linear velocity of this TF [m/s]</output_port>
            <output_port name="tf_frame_id">TF Full path</output_port>
        </SubTree>
        <Action ID="HaruGetHumor">
            <output_port name="humor" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Formatted Humor</output_port>
            <input_port name="humor_type" type="std::string">Type of Humor</input_port>
        </Action>
        <SubTree ID="HaruGetNewTelegramMsg">
            <output_port default="msg_audio_file_path" name="msg_audio_file_path">Received audio file absolute path</output_port>
            <output_port default="msg_audio_transcription" name="msg_audio_transcription">The audio transciption string</output_port>
            <output_port default="msg_emoji" name="msg_emoji">Emoji as string</output_port>
            <output_port default="msg_emoji_routine_id" name="msg_emoji_routine_id">Recommend routine for this emoji</output_port>
            <output_port default="msg_harumoji" name="msg_harumoji">Harumoji description</output_port>
            <output_port default="msg_harumoji_routine_id" name="msg_harumoji_routine_id">Recommended routine for this Harumoji</output_port>
            <output_port default="msg_id" name="msg_id">Unique ID of this msg for this telegram bot</output_port>
            <output_port default="msg_is_audio_transcribed" name="msg_is_audio_transcribed">True if the audio file transcription is enabled and was a success</output_port>
            <output_port default="msg_photo_file_path" name="msg_photo_file_path">Path to the received photo file</output_port>
            <output_port default="msg_text" name="msg_text">Text message string</output_port>
            <output_port default="msg_timestamp" name="msg_timestamp">Timestamp of this msg when it was received from the phone</output_port>
            <output_port default="msg_type" name="msg_type">Type of the message (text, audio, photo). Check the idmind_tabletop::TelegramMsg message definiton</output_port>
            <output_port default="num_msgs" name="num_msgs">Number of messages currently stored in the Telegram Server</output_port>
            <output_port default="num_unread_msgs" name="num_unread_msgs">Number of unread messages currently stored in the Telegram Server</output_port>
            <output_port default="user_chat_id" name="user_chat_id">Telegram chat ID of the user</output_port>
            <output_port default="user_firstname" name="user_firstname">First name of the user</output_port>
            <output_port default="user_name" name="user_name">Nick name of the user</output_port>
        </SubTree>
        <SubTree ID="HaruGetPersonDistance">
            <output_port name="distance">Distance from Haru to the person</output_port>
            <input_port name="frame_id">Namespace of body parts</input_port>
            <input_port name="person">Target person</input_port>
        </SubTree>
        <SubTree ID="HaruGetPersonHeadAngles">
            <input_port name="frame_id">Namespace of body parts</input_port>
            <input_port name="person">Target person</input_port>
            <output_port name="pitch">Person Head pitch respect to Haru</output_port>
            <output_port name="roll">Person Head roll respect to Haru</output_port>
            <output_port name="yaw">Person Head yaw respect to Haru</output_port>
        </SubTree>
        <SubTree ID="HaruGetPersonSpeech">
            <input_port name="person">Target person</input_port>
            <output_port name="speaker_confidence">Confidence about this speech belongs to this person</output_port>
            <output_port name="transcript_confidence">Speech transcription confidence</output_port>
            <output_port name="transcript_text">Speech transcription</output_port>
        </SubTree>
        <SubTree ID="HaruGetQRInfo">
            <input_port name="qr_info"/>
            <input_port name="timeout"/>
        </SubTree>
        <SubTree ID="HaruGetSpeakingPerson">
            <input_port name="people">People in scene</input_port>
            <output_port name="speaking_person">Speaking Person with hightest confidence</output_port>
        </SubTree>
        <SubTree ID="HaruGetTelegramUserList">
            <output_port name="success">True if the user list is not empty</output_port>
            <output_port name="user_list">JSON of current known user list as [{&quot;id&quot;: &quot;1234&quot;, &quot;username&quot;: &quot;ForExample&quot;, &quot;firstname&quot;: &quot;Example&quot;, &quot;akas&quot;:[&quot;Test&quot;,&quot;Try&quot;, ...]}, ...]</output_port>
        </SubTree>
        <Action ID="HaruGetTrivia">
            <output_port name="trivia" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Formatted Trivia</output_port>
            <input_port name="trivia_type" type="std::string">Type of Trivia</input_port>
        </Action>
        <SubTree ID="HaruGoHome"/>
        <SubTree ID="HaruLCDVideos">
            <input_port name="left_eye">Video for left eye from robot POV.</input_port>
            <input_port name="right_eye">Video for right eye from robot POV.</input_port>
        </SubTree>
        <SubTree ID="HaruLCDVideosAndWait">
            <input_port default="0" name="end_time">Time to stop LCD video play. Must be equal or higher than &quot;start_time&quot;. [milliseconds]</input_port>
            <output_port default="lcd_feed" name="feedback">LCD action feedback. Filled when action is running</output_port>
            <input_port name="left_eye">Video for left eye from robot POV.</input_port>
            <input_port default="0" name="loop">Play in loop?</input_port>
            <output_port default="lcd_result" name="result">LCD action result. Only once when the action finish</output_port>
            <input_port name="right_eye">Video for right eye from robot POV.</input_port>
            <input_port default="0" name="start_time">Time to start LCD video play. If this and &quot;end_time&quot; are 0 the entire file will be played [milliseconds]</input_port>
        </SubTree>
        <SubTree ID="HaruLCDVideosStop"/>
        <SubTree ID="HaruLEDsEyesPlay">
            <input_port name="eyes_file">File name to play in eyes. Only supports Gif files.</input_port>
        </SubTree>
        <SubTree ID="HaruLEDsMouthPlay">
            <input_port name="mouth_file">File to play in mouth. Only supports Gif files.</input_port>
        </SubTree>
        <SubTree ID="HaruLEDsStop">
            <input_port default="mouth" name="part">Stop executing Gif. mouth to stop the mouth, and eyes to stop the eyes.</input_port>
        </SubTree>
        <SubTree ID="HaruListensEveryone"/>
        <SubTree ID="HaruListensNobody"/>
        <SubTree ID="HaruListensPerson">
            <input_port name="person">Person to listen</input_port>
        </SubTree>
        <SubTree ID="HaruLookAt">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port default="false" name="base_control_vel">Enable/DIsable base velocity controller</input_port>
            <input_port default="false" name="disable_base">Disable/Enable base movement. True to disable</input_port>
            <input_port default="false" name="disable_eyes">Disable/Enable LCD eyes movement. True to disable</input_port>
            <input_port default="false" name="disable_head">Disable/Enable head movement. True to disable</input_port>
            <input_port default="false" name="disable_neck">Disable/Enable neck movement. True to disable</input_port>
            <input_port default="1.0" name="high">Positive up, negative down. (Z)</input_port>
            <input_port default="0.0" name="horizontal">Positive forward, negative backwards. From robot POV. (X)</input_port>
            <input_port default="1.0" name="proximity">Positive left, negative right. From robot POV. (Y)</input_port>
        </SubTree>
        <SubTree ID="HaruMarkTelegramMsgAsRead">
            <input_port name="msg_id">The unique ID of the message that you want to mark as already read</input_port>
            <output_port name="success">Service result, true it the message exists and it was marked as result or it was already a read message</output_port>
        </SubTree>
        <Action ID="HaruMonitorAudio">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::AudioStatus_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="HaruMonitorBrowser">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::ProjectorStatus_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="HaruMonitorFastestTF">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::TFSpeed_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="HaruMonitorLCD">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::LCDStatus_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="HaruMonitorProjector">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::ProjectorStatus_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="HaruMonitorRoutine">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::RoutineStatus_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="HaruMonitorTTS">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::TTSStatus_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="HaruMonitorTrack">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::TrackStatus_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <SubTree ID="HaruNlpYesNo">
            <output_port name="answer">Yes or no answer</output_port>
            <input_port name="transcription">Text to processs</input_port>
        </SubTree>
        <SubTree ID="HaruProjectorCloseWeb"/>
        <SubTree ID="HaruProjectorImage">
            <input_port default="0" name="always">Show the image always? If set to true, &quot;img_duration&quot; will be ignored</input_port>
            <input_port name="img_duration">Time to show the image [milliseconds]</input_port>
            <input_port name="img_file">Name of the image to show (absolute or relative). Must include file extension.</input_port>
            <input_port default="1" name="img_scale">0: real resolution respect to the monitor; 1: scale to the limit of the monitor resolution keeping the original proportions, 2: scale to the limit of the monitor resolution without keeping original proportions</input_port>
        </SubTree>
        <SubTree ID="HaruProjectorImageAndWait">
            <input_port name="duration">Time to show the image [milliseconds]</input_port>
            <output_port default="projector_image_feed" name="feedback">Projector action feedback. Filled when action is running</output_port>
            <input_port name="image_file">Name of the image to show (absolute or relative). Must include file extension.</input_port>
            <input_port default="1" name="image_scale">0: real resolution respect to the monitor; 1: scale to the limit of the monitor resolution keeping the original proportions, 2: scale to the limit of the monitor resolution without keeping original proportions</input_port>
            <input_port default="1" name="keep_last">Keep last frame on projector? 0: no  1: yes</input_port>
            <input_port default="0" name="loop">Show the image always? If set to true, &quot;duration&quot; will be ignored</input_port>
            <output_port default="projector_image_result" name="result">Projector action result. Only once when the action finish</output_port>
        </SubTree>
        <SubTree ID="HaruProjectorShowLastWeb"/>
        <SubTree ID="HaruProjectorShowWeb">
            <input_port name="url">URL of website to show</input_port>
        </SubTree>
        <SubTree ID="HaruProjectorStop"/>
        <SubTree ID="HaruProjectorVideo">
            <input_port default="0" name="end_time">Time to stop video play. Must be equal or higher than &quot;start_time&quot;. [milliseconds]</input_port>
            <input_port default="1" name="keep_last">Keep last frame on projector? 0: no  1: yes</input_port>
            <input_port default="0" name="loop">Play in loop?</input_port>
            <input_port default="0" name="start_time">Time to start video play. If this and &quot;end_time&quot; are 0 the entire file will be played [milliseconds]</input_port>
            <input_port name="video_file">Name of the video to play (absolute or relative). Must include file extension.</input_port>
            <input_port default="1" name="video_scale">0: real resolution respect to the monitor; 1: scale to the limit of the monitor resolution keeping the original proportions, 2: scale to the limit of the monitor resolution without keeping original proportions</input_port>
        </SubTree>
        <SubTree ID="HaruProjectorVideoAndWait">
            <input_port default="0" name="end_time">Time to stop video play. Must be equal or higher than &quot;start_time&quot;. [milliseconds]</input_port>
            <output_port default="projector_video_feed" name="feedback">Projector action feedback. Filled when action is running</output_port>
            <input_port default="1" name="keep_last">Keep last frame on projector? 0: no  1: yes</input_port>
            <input_port default="0" name="loop">Play in loop?</input_port>
            <output_port default="projector_video_result" name="result">Projector action result. Only once when the action finish</output_port>
            <input_port default="0" name="start_time">Time to start video play. If this and &quot;end_time&quot; are 0 the entire file will be played [milliseconds]</input_port>
            <input_port name="video_file">Name of the video to play (absolute or relative). Must include file extension.</input_port>
            <input_port default="1" name="video_scale">0: real resolution respect to the monitor; 1: scale to the limit of the monitor resolution keeping the original proportions, 2: scale to the limit of the monitor resolution without keeping original proportions</input_port>
        </SubTree>
        <Action ID="HaruPublishASRCommand">
            <input_port name="command" type="std::string">Command Type</input_port>
        </Action>
        <SubTree ID="HaruReadQR">
            <output_port name="qr_content">Content of the QR code detected</output_port>
            <input_port default="10.0" name="timeout">Max time to detect a QR code [seconds]</input_port>
        </SubTree>
        <SubTree ID="HaruReceptionMainWebPage">
            <output_port default="web_success" name="success">Webpage set or not [1/0]</output_port>
            <output_port default="website_url" name="website_url">Website url</output_port>
        </SubTree>
        <SubTree ID="HaruReceptionMeetingWebPage">
            <input_port name="guest_name">Name of the guest. Only one person</input_port>
            <input_port name="hosts">Hosts for the meeting. Up to two names separeted by ;</input_port>
            <input_port name="meeting_end">Time the meeting ends</input_port>
            <input_port name="meeting_name">Name of the meeting</input_port>
            <input_port name="meeting_start">Time the meeting starts</input_port>
            <input_port name="room">Name of the room where the meeting is held</input_port>
            <output_port default="web_success" name="success">Website set or not [1/0]</output_port>
            <output_port default="website_url" name="website_url">Website URL</output_port>
        </SubTree>
        <SubTree ID="HaruReceptionProfileWebPage">
            <input_port name="company">Name of the guest's company</input_port>
            <input_port name="guest_name">Name of the guest</input_port>
            <input_port name="image_path">Full path of the image for the guest profile</input_port>
            <input_port name="position">Position of the guest inside its company</input_port>
            <output_port default="web_success" name="success">Web set or not [1/0]</output_port>
            <output_port default="website_url" name="website_url">Website URL</output_port>
        </SubTree>
        <SubTree ID="HaruReceptionQRWebPage">
            <output_port default="web_success" name="success">Web set or not [1/0]</output_port>
            <output_port default="website_url" name="website_url">Website URL</output_port>
        </SubTree>
        <SubTree ID="HaruReceptionWeatherWebPage">
            <output_port default="web_success" name="success">Web set or not [1/0]</output_port>
            <output_port default="website_url" name="website_url">Website URL</output_port>
        </SubTree>
        <SubTree ID="HaruReceptionWelcomeWebPage">
            <output_port default="web_success" name="success">Web set or not [1/0]</output_port>
            <output_port default="website_url" name="website_url">Website URL</output_port>
        </SubTree>
        <SubTree ID="HaruReceptionWifiWebPage">
            <input_port name="network">Name of the WiFi network</input_port>
            <input_port name="password">Password of the WiFi network</input_port>
            <output_port default="success" name="success">Web created or not</output_port>
            <output_port default="website_url" name="website_url">URL of website created</output_port>
        </SubTree>
        <SubTree ID="HaruSendTelegramAudio">
            <input_port name="chat_id">Telegram user chat ID to send the audio file</input_port>
            <input_port name="file_path">Full Path to the audio file</input_port>
            <output_port name="success">True if the audio was sent successfully</output_port>
        </SubTree>
        <SubTree ID="HaruSendTelegramImage">
            <input_port name="accepted">Set to 1 if you have accepted to send the image or 0 otherwise</input_port>
            <input_port name="camera_topic">ROS Image Topic to be used to send the image to the phone</input_port>
            <input_port name="chat_id">Telegram user chat id</input_port>
            <output_port name="success">True if the image was sent correctly</output_port>
        </SubTree>
        <SubTree ID="HaruSendTelegramText">
            <input_port name="chat_id">Telegram user chat id to send the text to</input_port>
            <output_port name="success">True if the text was sent correctly</output_port>
            <input_port name="text">The text message to send to</input_port>
        </SubTree>
        <SubTree ID="HaruSetLanguage">
            <input_port name="language">Language to set. Supported languages &quot;en&quot;, &quot;es&quot; and &quot;ja&quot; for English, Spanish and Japanese</input_port>
        </SubTree>
        <SubTree ID="HaruSetVoice">
            <input_port name="voice">Name of the voice to set</input_port>
        </SubTree>
        <SubTree ID="HaruSpeakExpressive">
            <input_port name="text">Text to process</input_port>
        </SubTree>
        <SubTree ID="HaruSpeaksEmoTTSAndWait">
            <output_port default="tts_feed" name="feedback">TTS action feedback. Filled when action is running</output_port>
            <input_port name="genre">Genre tag that haru uses for its tone of voice</input_port>
            <input_port name="phrases">Phrase for Haru to say. Random choose between senteces separeted by ;</input_port>
            <output_port default="tts_result" name="result">TTS action result. Only once when the action finish</output_port>
        </SubTree>
        <SubTree ID="HaruSpeaksTTS">
            <input_port name="phrases">Phrase for Haru to say. Random choose between senteces separeted by ;</input_port>
        </SubTree>
        <SubTree ID="HaruSpeaksTTSAndWait">
            <output_port default="tts_feed" name="feedback">TTS action feedback. Filled when action is running</output_port>
            <input_port name="phrases">Phrase for Haru to say. Random choose between senteces separeted by ;</input_port>
            <output_port default="tts_result" name="result">TTS action result. Only once when the action finish</output_port>
        </SubTree>
        <SubTree ID="HaruSpeaksTTSAndWaitDEPRECATE">
            <input_port name="phrases">Phrase for Haru to say. Random choose between senteces separeted by ;</input_port>
        </SubTree>
        <SubTree ID="HaruStartTimeCount">
            <input_port default="0" name="timer_id">Timer identifier</input_port>
        </SubTree>
        <SubTree ID="HaruStopTimeCount">
            <output_port name="time_elapsed">Time the timer was running [millisenconds]</output_port>
            <input_port default="0" name="timer_id">Timer identifier</input_port>
        </SubTree>
        <SubTree ID="HaruStopsRoutines"/>
        <SubTree ID="HaruStopsTracking"/>
        <SubTree ID="HaruSwitchAudioDucking">
            <input_port name="enable">Disable/enable audio ducking: 0/1</input_port>
            <input_port default="1" name="main_channel_id">ID of main channel in audio ducking. 1: speech channel</input_port>
        </SubTree>
        <SubTree ID="HaruTakePhoto">
            <input_port name="image_name">Name of the image ;</input_port>
            <input_port name="path">Path to save the image ;</input_port>
        </SubTree>
        <SubTree ID="HaruTrackPerson">
            <input_port default="head" name="body_part">Body part of person to track: spine_base, spine_shoulder, spine_mid, neck, head, shoulder_left, elbow_left, wrist_left, hand_left, hip_left, knee_left, ankle_left, foot_left, sames with _right</input_port>
            <input_port name="person">Person to track</input_port>
            <input_port name="person_header">Header of person to track</input_port>
        </SubTree>
        <SubTree ID="HaruTrackPosition">
            <input_port name="frame">Name of the frame to track</input_port>
        </SubTree>
        <SubTree ID="HaruTrackVelocity">
            <input_port name="frame">Name of the frame to track</input_port>
        </SubTree>
        <Action ID="HaruWebsiteShowGenericPage">
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::ShowGenericPageResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="HaruWebsiteShowMeetingPage">
            <input_port name="hosts" type="std::string">Auto-generated field from idmind_tabletop_msgs::ShowMeetingPageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="meeting_end" type="std::string">Auto-generated field from idmind_tabletop_msgs::ShowMeetingPageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="meeting_name" type="std::string">Auto-generated field from idmind_tabletop_msgs::ShowMeetingPageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="meeting_start" type="std::string">Auto-generated field from idmind_tabletop_msgs::ShowMeetingPageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="room" type="std::string">Auto-generated field from idmind_tabletop_msgs::ShowMeetingPageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::ShowMeetingPageResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="visitor_name" type="std::string">Auto-generated field from idmind_tabletop_msgs::ShowMeetingPageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="HaruWebsiteShowProfilePage">
            <input_port name="company" type="std::string">Auto-generated field from idmind_tabletop_msgs::ShowProfilePageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="guest_name" type="std::string">Auto-generated field from idmind_tabletop_msgs::ShowProfilePageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="image_location" type="std::string">Auto-generated field from idmind_tabletop_msgs::ShowProfilePageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="position" type="std::string">Auto-generated field from idmind_tabletop_msgs::ShowProfilePageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::ShowProfilePageResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="HaruWebsiteShowWifiPage">
            <input_port name="network" type="std::string">Auto-generated field from idmind_tabletop_msgs::ShowWifiPageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="password" type="std::string">Auto-generated field from idmind_tabletop_msgs::ShowWifiPageRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [idmind_tabletop_msgs::ShowWifiPageResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="IDselectionApiCallAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="osef" type="std::string">oseeeeeeeeeeeef</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonWakeUpWordFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonWakeUpWordResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
        </Action>
        <Action ID="InfoLog">
            <input_port name="message" type="std::string">Message to log</input_port>
        </Action>
        <Action ID="InitializeJson">
            <output_port name="output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Output variable to initialize</output_port>
        </Action>
        <SubTree ID="IsHaruAudioPlaying"/>
        <SubTree ID="IsHaruLCDPlaying"/>
        <SubTree ID="IsHaruProjectorPlaying"/>
        <SubTree ID="IsHaruRoutinePlaying"/>
        <SubTree ID="IsHaruSpeaking"/>
        <SubTree ID="IsHaruTracking"/>
        <Action ID="IstApiCallAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="sentence" type="std::string">user sentence</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonWakeUpWordFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonWakeUpWordResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="to_filter" type="std::string">Things from the sentence you want removed</input_port>
        </Action>
        <SubTree ID="IstCleanupText">
            <output_port name="cleaned_sentence">software output</output_port>
            <output_port name="input_flag">software output</output_port>
            <input_port name="sentence">User sentence</input_port>
        </SubTree>
        <SubTree ID="IstSendToHaru">
            <output_port name="answer_haru">software output</output_port>
            <input_port name="sentence">User sentence</input_port>
            <input_port name="to_filter">Things from the sentence you want removed</input_port>
        </SubTree>
        <Action ID="IstSteeredApiCallAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="emotion_wished" type="std::string">Emotion steering for Haru's line</input_port>
            <input_port name="sentence" type="std::string">user sentence</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonWakeUpWordFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonWakeUpWordResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="to_filter" type="std::string">Things from the sentence you want removed</input_port>
        </Action>
        <SubTree ID="IstSteeredSendToHaru">
            <output_port name="answer_haru">software output</output_port>
            <input_port name="emotion_wished">Emotion steering for Haru's line</input_port>
            <input_port name="sentence">User sentence</input_port>
            <input_port name="to_filter">Things from the sentence you want removed</input_port>
        </SubTree>
        <Action ID="LoadYamlFile">
            <input_port name="file_path" type="std::string">Path to the YAML config file</input_port>
            <output_port name="output" type="std::string">Parameter list as json</output_port>
        </Action>
        <Action ID="LookupTransform">
            <output_port name="output" type="tf::StampedTransform">Result transform</output_port>
            <input_port name="source_frame" type="std::string">Origin TF frame</input_port>
            <input_port name="target_frame" type="std::string">Target TF frame</input_port>
            <input_port default="0" name="use_last_available" type="bool">Use last available transform?</input_port>
        </Action>
        <Action ID="MonitorStdBool">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [std_msgs::Bool_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="MonitorStdFloat64">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [std_msgs::Float64_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="MonitorStdInt32">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [std_msgs::Int32_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="MonitorStdString">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [std_msgs::String_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="MonitorStdUInt64">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [std_msgs::UInt64_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="NLPTextToSSML">
            <input_port name="criteria_name" type="std::string">Auto-generated field from strawberry_ros_msgs::TextToSSMLRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetClosestPersonResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="text" type="std::string">Auto-generated field from strawberry_ros_msgs::TextToSSMLRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="PeopleApiCallCheckPersonHasMaskById">
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::CheckPersonHasMaskByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::CheckPersonHasMaskByIdResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallCheckPersonHasMaskByName">
            <input_port name="person_name" type="std::string">Auto-generated field from strawberry_ros_msgs::CheckPersonHasMaskByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::CheckPersonHasMaskByNameResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallCheckPersonInteractionById">
            <input_port name="axis" type="std::string">Auto-generated field from strawberry_ros_msgs::CheckPersonInteractionByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::CheckPersonInteractionByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="point.x" type="double">Auto-generated field from strawberry_ros_msgs::CheckPersonInteractionByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="point.y" type="double">Auto-generated field from strawberry_ros_msgs::CheckPersonInteractionByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="point.z" type="double">Auto-generated field from strawberry_ros_msgs::CheckPersonInteractionByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::CheckPersonInteractionByIdResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="tolerance" type="float">Auto-generated field from strawberry_ros_msgs::CheckPersonInteractionByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="PeopleApiCallCheckPersonInteractionByName">
            <input_port name="axis" type="std::string">Auto-generated field from strawberry_ros_msgs::CheckPersonInteractionByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="person_name" type="std::string">Auto-generated field from strawberry_ros_msgs::CheckPersonInteractionByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="point.x" type="double">Auto-generated field from strawberry_ros_msgs::CheckPersonInteractionByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="point.y" type="double">Auto-generated field from strawberry_ros_msgs::CheckPersonInteractionByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="point.z" type="double">Auto-generated field from strawberry_ros_msgs::CheckPersonInteractionByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::CheckPersonInteractionByNameResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="tolerance" type="float">Auto-generated field from strawberry_ros_msgs::CheckPersonInteractionByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="PeopleApiCallCheckPersonIsFemaleById">
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::CheckPersonIsFemaleByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::CheckPersonIsFemaleByIdResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallCheckPersonIsFemaleByName">
            <input_port name="person_name" type="std::string">Auto-generated field from strawberry_ros_msgs::CheckPersonIsFemaleByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::CheckPersonIsFemaleByNameResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetClosestPerson">
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetClosestPersonResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="source_pos.x" type="double">Auto-generated field from strawberry_ros_msgs::GetClosestPersonRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="source_pos.y" type="double">Auto-generated field from strawberry_ros_msgs::GetClosestPersonRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="source_pos.z" type="double">Auto-generated field from strawberry_ros_msgs::GetClosestPersonRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="PeopleApiCallGetNumberOfPersons">
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetNumberOfPersonsResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonBodyPartPosById">
            <input_port name="body_part" type="std::string">Auto-generated field from strawberry_ros_msgs::GetPersonBodyPartPosByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::GetPersonBodyPartPosByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonBodyPartPosByIdResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonBodyPartPosByName">
            <input_port name="body_part" type="std::string">Auto-generated field from strawberry_ros_msgs::GetPersonBodyPartPosByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="person_name" type="std::string">Auto-generated field from strawberry_ros_msgs::GetPersonBodyPartPosByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonBodyPartPosByNameResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonEmotionById">
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::GetPersonEmotionByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonEmotionByIdResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonEmotionByName">
            <input_port name="person_name" type="std::string">Auto-generated field from strawberry_ros_msgs::GetPersonEmotionByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonEmotionByNameResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonGestureById">
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::GetPersonGestureByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonGestureByIdResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonGestureByName">
            <input_port name="person_name" type="std::string">Auto-generated field from strawberry_ros_msgs::GetPersonGestureByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonGestureByNameResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonHandsDirById">
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::GetPersonHandsDirByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonHandsDirByIdResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonHandsDirByName">
            <input_port name="person_name" type="std::string">Auto-generated field from strawberry_ros_msgs::GetPersonHandsDirByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonHandsDirByNameResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonHandsPosById">
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::GetPersonHandsPosByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonHandsPosByIdResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonHandsPosByName">
            <input_port name="person_name" type="std::string">Auto-generated field from strawberry_ros_msgs::GetPersonHandsPosByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonHandsPosByNameResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonHeadDirById">
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::GetPersonHeadDirByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonHeadDirByIdResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonHeadDirByName">
            <input_port name="person_name" type="std::string">Auto-generated field from strawberry_ros_msgs::GetPersonHeadDirByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonHeadDirByNameResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonHeadPosById">
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::GetPersonHeadPosByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonHeadPosByIdResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonHeadPosByName">
            <input_port name="person_name" type="std::string">Auto-generated field from strawberry_ros_msgs::GetPersonHeadPosByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonHeadPosByNameResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonIdAndNameList">
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonIdAndNameListResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonIdByName">
            <input_port name="person_name" type="std::string">Auto-generated field from strawberry_ros_msgs::GetPersonIdByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonIdByNameResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonNameById">
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::GetPersonNameByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonNameByIdResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonPosById">
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::GetPersonPosByIdRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonPosByIdResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonPosByName">
            <input_port name="person_name" type="std::string">Auto-generated field from strawberry_ros_msgs::GetPersonPosByNameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonPosByNameResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonSpeechByIdAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::GetPersonSpeechByIdGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonSpeechByIdFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonSpeechByIdResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="timeout" type="float">Auto-generated field from strawberry_ros_msgs::GetPersonSpeechByIdGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonSpeechByNameAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="person_name" type="std::string">Auto-generated field from strawberry_ros_msgs::GetPersonSpeechByNameGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonSpeechByNameFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonSpeechByNameResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="timeout" type="float">Auto-generated field from strawberry_ros_msgs::GetPersonSpeechByNameGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonSpeechMaxConfidenceAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonSpeechMaxConfidenceFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonSpeechMaxConfidenceResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="timeout" type="float">Auto-generated field from strawberry_ros_msgs::GetPersonSpeechMaxConfidenceGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="PeopleApiCallGetPersonWakeUpWordAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonWakeUpWordFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonWakeUpWordResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="timeout" type="float">Auto-generated field from strawberry_ros_msgs::GetPersonWakeUpWordGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <SubTree ID="PeopleApiCheckPersonHasMaskById">
            <output_port name="has_mask">1(true) / 0(false) depending on the person has a mask or not</output_port>
            <input_port name="person_id">ID of the person to check if he is wearing a mask</input_port>
        </SubTree>
        <SubTree ID="PeopleApiCheckPersonHasMaskByName">
            <output_port name="has_mask">1(true) / 0(false) depending on the person has a mask or not</output_port>
            <input_port name="person_name">Name of the person to check if he is wearing a mask</input_port>
        </SubTree>
        <SubTree ID="PeopleApiCheckPersonIsFemaleById">
            <output_port name="is_female">1(true) / 0 (false) is the person is a female or a male</output_port>
            <input_port name="person_id">ID of the person to check if his gender</input_port>
        </SubTree>
        <SubTree ID="PeopleApiCheckPersonIsFemaleByName">
            <output_port name="is_female">1(true) / 0 (false) is the person is a female or a male</output_port>
            <input_port name="person_name">Name of the person to check his gender</input_port>
        </SubTree>
        <SubTree ID="PeopleApiCheckPersonIsLookingAtById">
            <input_port default="xyz" name="axis">Selected Axis to perform the check. Valid values: x, y, z, xy, xz, yz, xyz</input_port>
            <input_port name="person_id">ID of the person to check if it he looking at the source position</input_port>
            <input_port name="source_x">X axis of the source position</input_port>
            <input_port name="source_y">Y axis of the source position</input_port>
            <input_port name="source_z">Z axis of the source position</input_port>
            <output_port name="success">True if the person is looking at (tolerance) to the source position</output_port>
            <input_port default="25.0" name="tolerance">Tolerance to perform the check [degrees]</input_port>
        </SubTree>
        <SubTree ID="PeopleApiCheckPersonIsLookingAtByName">
            <input_port default="xyz" name="axis">Selected Axis to perform the check. Valid values: x, y, z, xy, xz, yz, xyz</input_port>
            <input_port name="person_name">Name of the person to check if he is looking at the source position</input_port>
            <input_port name="source_x">X axis of the source position</input_port>
            <input_port name="source_y">Y axis of the source position</input_port>
            <input_port name="source_z">Z axis of the source position</input_port>
            <output_port name="success">True if the person is looking at (tolerance) to the source position</output_port>
            <input_port default="25.0" name="tolerance">Tolerance to perform the check [degrees]</input_port>
        </SubTree>
        <SubTree ID="PeopleApiCheckPersonIsNearToById">
            <input_port default="xyz" name="axis">Selected Axis to perform the check. Valid values: x, y, z, xy, xz, yz, xyz</input_port>
            <input_port name="person_id">ID of the person to check if it he near to the source position</input_port>
            <input_port name="source_x">X axis of the source position</input_port>
            <input_port name="source_y">Y axis of the source position</input_port>
            <input_port name="source_z">Z axis of the source position</input_port>
            <output_port name="success">True if the person is near enough (tolerance) to the source position</output_port>
            <input_port default="1.0" name="tolerance">Tolerance to perform the check [meters]</input_port>
        </SubTree>
        <SubTree ID="PeopleApiCheckPersonIsNearToByName">
            <input_port default="xyz" name="axis">Selected Axis to perform the check. Valid values: x, y, z, xy, xz, yz, xyz</input_port>
            <input_port name="person_name">Name of the person to check if he is near to the source position</input_port>
            <input_port name="source_x">X axis of the source position</input_port>
            <input_port name="source_y">Y axis of the source position</input_port>
            <input_port name="source_z">Z axis of the source position</input_port>
            <output_port name="success">True if the person is near enough (tolerance) to the source position</output_port>
            <input_port default="1.0" name="tolerance">Tolerance to perform the check [meters]</input_port>
        </SubTree>
        <SubTree ID="PeopleApiCheckPersonIsPointingToById">
            <input_port default="xyz" name="axis">Selected Axis to perform the check. Valid values: x, y, z, xy, xz, yz, xyz</input_port>
            <input_port name="person_id">ID of the person to check if he is poiting to the source position</input_port>
            <input_port name="source_x">X axis of the source position</input_port>
            <input_port name="source_y">Y axis of the source position</input_port>
            <input_port name="source_z">Z axis of the source position</input_port>
            <output_port name="success">True if the person is pointing to (tolerance) to the source position</output_port>
            <input_port default="25.0" name="tolerance">Tolerance to perform the check [degrees]</input_port>
        </SubTree>
        <SubTree ID="PeopleApiCheckPersonIsPointingToByName">
            <input_port default="xyz" name="axis">Selected Axis to perform the check. Valid values: x, y, z, xy, xz, yz, xyz</input_port>
            <input_port name="person_name">Name of the person to check if he is looking at the source position</input_port>
            <input_port name="source_x">X axis of the source position</input_port>
            <input_port name="source_y">Y axis of the source position</input_port>
            <input_port name="source_z">Z axis of the source position</input_port>
            <output_port name="success">True if the person is pointing to (tolerance) to the source position</output_port>
            <input_port default="25.0" name="tolerance">Tolerance to perform the check [degrees]</input_port>
        </SubTree>
        <SubTree ID="PeopleApiGetClosestPerson">
            <output_port name="person_id">ID of the closest person to the source position</output_port>
            <output_port name="person_name">Name of the closest person to the source position</output_port>
            <input_port name="source_x">X axis of the source position to check who is the closest person to</input_port>
            <input_port name="source_y">Y axis of the source position to check who is the closest person to</input_port>
            <input_port name="source_z">Z axis of the source position to check who is the closest person to</input_port>
        </SubTree>
        <SubTree ID="PeopleApiGetIdAndNameLists">
            <output_port name="ids">Json with the list of ids</output_port>
            <output_port name="names">Json with the list of names</output_port>
            <output_port name="names_and_ids">Json with a list of two fields: /name and /id</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetNumberOfPersons">
            <output_port name="value">Current number of detected persons</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonBodyPartPosByID">
            <input_port name="body_part_name">Body part name we want to get its position</input_port>
            <input_port name="person_id">Person ID that this body part belongs to</input_port>
            <output_port name="x">Body Part position X axis</output_port>
            <output_port name="y">Body Part position Y axis</output_port>
            <output_port name="z">Body Part position Z axis</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonBodyPartPosByName">
            <input_port name="body_part_name">Body part name to get its position</input_port>
            <input_port name="person_name">Person Name to get the body part position</input_port>
            <output_port name="x">Body part position X axis</output_port>
            <output_port name="y">Body part position Y axis</output_port>
            <output_port name="z">Body part position Z axis</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonEmotionById">
            <output_port name="emotion_name">Current face emotion</output_port>
            <input_port name="person_id">ID of the person to get his current face emotion</input_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonEmotionByName">
            <output_port name="emotion_name">Current face emotion</output_port>
            <input_port name="person_name">Name of the person to get his current face emotion</input_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonGestureById">
            <output_port name="gesture_name">Current body gesture</output_port>
            <input_port name="person_id">ID of the person to get his current body gesture</input_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonGestureByName">
            <output_port name="gesture_name">Body gesture name</output_port>
            <input_port name="person_name">Name of the person to get his current body gesture</input_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonHandsDirById">
            <output_port name="left_hand_x">Left Hand direction X axis</output_port>
            <output_port name="left_hand_y">Left Hand direction Y axis</output_port>
            <output_port name="left_hand_z">Left Hand direction Z axis</output_port>
            <input_port name="person_id">Person ID to get his hand directions</input_port>
            <output_port name="right_hand_x">Right Hand direction X axis</output_port>
            <output_port name="right_hand_y">Right Hand direction Y axis</output_port>
            <output_port name="right_hand_z">Right Hand direction Z axis</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonHandsDirByName">
            <output_port name="left_hand_x">Left Hand direction X axis</output_port>
            <output_port name="left_hand_y">Left Hand direction Y axis</output_port>
            <output_port name="left_hand_z">Left Hand direction Z axis</output_port>
            <input_port name="person_name">Name of the person to get the hands directions</input_port>
            <output_port name="right_hand_x">Right Hand direction X axis</output_port>
            <output_port name="right_hand_y">Right Hand direction Y axis</output_port>
            <output_port name="right_hand_z">Right Hand direction Z axis</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonHandsPosById">
            <output_port name="left_hand_x">Left Hand position X axis</output_port>
            <output_port name="left_hand_y">Left Hand position Y axis</output_port>
            <output_port name="left_hand_z">Left Hand position Z axis</output_port>
            <input_port name="person_id">Person ID to get his hands positions</input_port>
            <output_port name="right_hand_x">Right Hand position X axis</output_port>
            <output_port name="right_hand_y">Right Hand position Y axis</output_port>
            <output_port name="right_hand_z">Right Hand position Z axis</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonHandsPosByName">
            <output_port name="left_hand_x">Left Hand position X axis</output_port>
            <output_port name="left_hand_y">Left Hand position Y axis</output_port>
            <output_port name="left_hand_z">Left Hand position Z axis</output_port>
            <input_port name="person_name">Person name to get his hands positions</input_port>
            <output_port name="right_hand_x">Right Hand position X axis</output_port>
            <output_port name="right_hand_y">Right Hand position Y axis</output_port>
            <output_port name="right_hand_z">Right Hand position Z axis</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonHeadDirById">
            <input_port name="person_id">ID of the person to get his head direction</input_port>
            <output_port name="x">Head direction X axis</output_port>
            <output_port name="y">Head direction Y axis</output_port>
            <output_port name="z">Head direction Z axis</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonHeadDirByName">
            <input_port name="person_name">Name of the person to get his head direction</input_port>
            <output_port name="x">Head direction X axis</output_port>
            <output_port name="y">Head direction Y axis</output_port>
            <output_port name="z">Head direction Z axis</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonHeadPosById">
            <input_port name="person_id">ID of the person to get his head position</input_port>
            <output_port name="x">Head position X axis</output_port>
            <output_port name="y">Head position Y axis</output_port>
            <output_port name="z">Head position Z axis</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonHeadPosByName">
            <input_port name="person_name">Name of the person to get his head position</input_port>
            <output_port name="x">Head position X axis</output_port>
            <output_port name="y">Head position Y axis</output_port>
            <output_port name="z">Head position Z axis</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonIdByName">
            <output_port name="person_id">Id of the person with this name</output_port>
            <input_port name="person_name">Name of the person</input_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonNameById">
            <input_port name="person_id">Id of the person</input_port>
            <output_port name="person_name">Name of the person with this ID</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonPosById">
            <input_port name="person_id">ID of the person we want to know his position</input_port>
            <output_port name="x">Person position X axis</output_port>
            <output_port name="y">Person position Y axis</output_port>
            <output_port name="z">Person position Z axis</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonPosByName">
            <input_port name="person_name">Name of the person we want to know his position</input_port>
            <output_port name="x">Person position X axis</output_port>
            <output_port name="y">Person position Y axis</output_port>
            <output_port name="z">Person position Z axis</output_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonSpeechByIdAndWait">
            <input_port name="person_id">ID of the person to get his speech</input_port>
            <output_port name="speaker_confidence">Confidence about this person ID was the actual speaker</output_port>
            <output_port name="speech_confidence">Confidence about the transcription</output_port>
            <output_port name="speech_id">Unique ID for each speech result. Use it to identify older results</output_port>
            <output_port name="speech_text">Speech result text</output_port>
            <output_port name="success">True if speech was found for this person ID</output_port>
            <input_port default="0.0" name="timeout">Time to wait for a speech result for this person ID [seconds]. A value of 0.0 means just try one</input_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonSpeechByNameAndWait">
            <input_port name="person_name">Name of the person to get his speech</input_port>
            <output_port name="speaker_confidence">Confidence about this person ID was the actual speaker</output_port>
            <output_port name="speech_confidence">Confidence about the transcription</output_port>
            <output_port name="speech_id">Unique ID for each speech result. Use it to identify older results</output_port>
            <output_port name="speech_text">Speech result text</output_port>
            <output_port name="success">True if speech was found for this person ID</output_port>
            <input_port default="0.0" name="timeout">Time to wait for a speech result for this person ID [seconds]. A value of 0.0 means just try one</input_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonSpeechMaxConfidenceAndWait">
            <output_port name="person_id">ID of the person to whom this speech belongs</output_port>
            <output_port name="person_name">Name of the person to whom this speech belongs</output_port>
            <output_port name="speaker_confidence">Confidence about this person ID was the actual speaker</output_port>
            <output_port name="speech_confidence">Confidence about the transcription</output_port>
            <output_port name="speech_id">Unique ID for each speech result. Use it to identify older results</output_port>
            <output_port name="speech_text">Speech result text</output_port>
            <output_port name="success">True if speech was found for this person ID</output_port>
            <input_port default="0.0" name="timeout">Time to wait for a speech result for this person ID [seconds]. A value of 0.0 means just try one</input_port>
        </SubTree>
        <SubTree ID="PeopleApiGetPersonWakeUpWordAndWait">
            <output_port name="person_found">True if a person was found with a non null wake up word</output_port>
            <output_port name="person_id">ID of the person to whom this speech belongs</output_port>
            <output_port name="person_name">Name of the person to whom this speech belongs</output_port>
            <output_port name="speaker_confidence">Confidence about this person ID was the actual speaker</output_port>
            <output_port name="speech_confidence">Confidence about the transcription</output_port>
            <output_port name="speech_id">Unique ID for each speech result. Use it to identify older results</output_port>
            <output_port name="speech_text">Speech result text</output_port>
            <input_port default="0.0" name="timeout">Time to wait for a speech result for this person ID [seconds]. A value of 0.0 means just try one</input_port>
            <output_port name="wake_up_word">WakeUpWord value: True if a person told the wake up word</output_port>
        </SubTree>
        <Action ID="PublishStdBool">
            <input_port name="data" type="bool">Auto-generated field from std_msgs::Bool_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="PublishStdEmpty">
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="PublishStdFloat64">
            <input_port name="data" type="double">Auto-generated field from std_msgs::Float64_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="PublishStdInt32">
            <input_port name="data" type="int">Auto-generated field from std_msgs::Int32_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="PublishStdString">
            <input_port name="data" type="std::string">Auto-generated field from std_msgs::String_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="PublishStdUInt64">
            <input_port name="data" type="unsigned long">Auto-generated field from std_msgs::UInt64_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <SubTree ID="RosTeleconferenceAudioOFF">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <output_port default="pause_tele_audio_result" name="output">Service result</output_port>
        </SubTree>
        <SubTree ID="RosTeleconferenceAudioON">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <output_port default="resume_tele_audio_result" name="output">Service result</output_port>
        </SubTree>
        <SubTree ID="RosTeleconferenceSyncBuffReset"/>
        <SubTree ID="SaveImage">
            <input_port name="image_file">Full path of the file to be saved. File extension should be included</input_port>
            <input_port name="image_topic">Name of the topic to save the image from</input_port>
        </SubTree>
        <Action ID="SpeechDetectionApiCallAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="checking_time" type="std::float32">required silence time</input_port>
            <input_port name="mode" type="std::string">detection mode</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonWakeUpWordFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonWakeUpWordResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="turn_max_time" type="std::float32">max turn time</input_port>
        </Action>
        <Action ID="SplitStringToJsonArray">
            <input_port default=";" name="delimiter" type="std::string">delimiter to split the sequence</input_port>
            <output_port name="json_size" type="unsigned long">Number of elements from the split</output_port>
            <output_port name="output_json" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Json array with the sequence splitted</output_port>
            <input_port name="sequence" type="std::string">Sequence to split</input_port>
        </Action>
        <SubTree ID="StrawberryASRToDialog">
            <input_port name="asr_result_msg">Full ASR result message</input_port>
        </SubTree>
        <SubTree ID="StrawberryAddDialogEntity">
            <input_port default="0" name="auto_expansion">Enable / disable ML auto-expansion [1 / 0].</input_port>
            <input_port name="entities">Serialized JSON with keys as entity values and values as coma-separated synonym strings</input_port>
            <input_port name="entity_name">Name of the Entity type to add entities. Must be one of those received from topic /strawberry/dialog_entity_types_list.</input_port>
            <input_port default="0" name="fuzzy_extraction">Enable / disable fuzzy extraction of entities [1 / 0]</input_port>
            <input_port default="KIND_MAP" name="kind">Kind of the Entity type. Must be one of: KIND_MAP, KIND_LIST, KIND_REGEXP. Defaults to KIND_MAP.</input_port>
        </SubTree>
        <SubTree ID="StrawberryAppendDialogSessionEntity">
            <input_port name="entities">Serialized JSON with keys as entity values and values as coma-separated synonym strings</input_port>
            <input_port name="entity_name">Name of the Entity type to append entities. Must be one of those received from topic /strawberry/dialog_entity_types_list.</input_port>
            <input_port name="person_id">Unique ID of the person with white the event is associated</input_port>
            <output_port name="session_entities">List of entities available on this session</output_port>
        </SubTree>
        <Action ID="StrawberryClassifyEmotionFromText">
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::ClassifyEmotionFromTextResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="transcription" type="std::string">Auto-generated field from strawberry_ros_msgs::ClassifyEmotionFromTextRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="StrawberryCommandEnableASR">
            <input_port name="data" type="bool">Auto-generated field from strawberry_ros_msgs::Enable_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="header.frame_id" type="std::string">Auto-generated field from strawberry_ros_msgs::Enable_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="header.seq" type="unsigned int">Auto-generated field from strawberry_ros_msgs::Enable_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="StrawberryCommandSpeech">
            <input_port name="asr_result.confidence" type="float">Auto-generated field from strawberry_ros_msgs::Speech_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="asr_result.header.frame_id" type="std::string">Auto-generated field from strawberry_ros_msgs::Speech_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="asr_result.header.seq" type="unsigned int">Auto-generated field from strawberry_ros_msgs::Speech_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="asr_result.transcript" type="std::string">Auto-generated field from strawberry_ros_msgs::Speech_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::Speech_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="speaker_confidence" type="float">Auto-generated field from strawberry_ros_msgs::Speech_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
            <input_port name="wake_up_word" type="bool">Auto-generated field from strawberry_ros_msgs::Speech_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="StrawberryControlEntity">
            <input_port default="ADD" name="action" type="std::string">Name of the action to perform on the Entity. Can be either ADD or REMOVE only. Defaults to ADD</input_port>
            <input_port default="0" name="auto_expansion_mode" type="bool">Enable / disable ML auto-expansion. Must be either true or false. Defaults to false.</input_port>
            <input_port default="0" name="enable_fuzzy_extraction" type="bool">Enable / disable fuzzy extraction of entities. Must be either false or false. Defaults to false.</input_port>
            <input_port name="entities" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized JSON with keys as entity values and values as coma-separated synonym strings</input_port>
            <input_port name="entity_name" type="std::string">Name of the Entity type. Must be one of those received from topic /strawberry/dialog_entity_types_list.</input_port>
            <input_port default="KIND_MAP" name="kind" type="std::string">Kind of the Entity type. Must be one of: KIND_MAP, KIND_LIST, KIND_REGEXP. Defaults to KIND_MAP.</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::ControlEntityResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="StrawberryControlSessionEntity">
            <input_port default="ADD" name="action" type="std::string">Name of the action to perform on the Entity. Can be either GET, ADD or REMOVE only. Defaults to ADD</input_port>
            <input_port name="entities" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized JSON with keys as entity values and values as coma-separated synonym strings</input_port>
            <input_port name="entity_name" type="std::string">Name of the Entity type. Must be one of those received from topic /strawberry/dialog_entity_types_list.</input_port>
            <input_port default="SUPPLEMENT" name="entity_override_mode" type="std::string">Session entity override mode. Must be one of: OVERRIDE or SUPPLEMENT. Defaults to SUPPLEMENT.</input_port>
            <input_port name="person_id" type="unsigned int">Unique ID of the person with white the event is associated</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::ControlSessionEntityResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <SubTree ID="StrawberryDialogAskYesNoQuestion">
            <input_port name="question">Question to ask the speaker. Can be multiple questions separated by semicolon. Random question will be selected.</input_port>
        </SubTree>
        <SubTree ID="StrawberryDisableASR"/>
        <SubTree ID="StrawberryDisableAllASR"/>
        <SubTree ID="StrawberryDisableDialogGenericQuestions"/>
        <SubTree ID="StrawberryEnableASR"/>
        <SubTree ID="StrawberryEnableAllASR"/>
        <SubTree ID="StrawberryGetASR">
            <output_port name="asr_result">Sentece detected</output_port>
            <output_port name="asr_result_conf">Confidence of sentence detected</output_port>
            <output_port name="asr_result_msg">Full ASR result message</output_port>
        </SubTree>
        <SubTree ID="StrawberryGetDialog">
            <output_port name="dialog_response">Response sentence</output_port>
            <output_port name="dialog_result">Full dialogue result</output_port>
        </SubTree>
        <SubTree ID="StrawberryGetDialogIntent">
            <output_port name="dialog_intent">Intent of the dialogue response</output_port>
            <output_port name="dialog_intent_confidence">Confidence of the intent detected</output_port>
            <input_port name="dialog_result">Message of dialogue module</input_port>
        </SubTree>
        <SubTree ID="StrawberryGetDialogSessionEntity">
            <input_port name="person_id">Unique ID of the person with white the event is associated</input_port>
            <output_port name="session_entities">List of entities available on this session</output_port>
        </SubTree>
        <SubTree ID="StrawberryGetDialogUtterance">
            <input_port name="dialog_result">Dialog result message [strawberry_ros_msgs/DialogResult]</input_port>
            <output_port name="dialog_utterance">Original ASR utterance that was processed by the dialog</output_port>
        </SubTree>
        <SubTree ID="StrawberryGetGonePeople">
            <output_port name="gone_people">People that left the scene</output_port>
        </SubTree>
        <SubTree ID="StrawberryGetHands">
            <output_port name="hands">Detected hands</output_port>
            <output_port name="hands_msg">Full hands message</output_port>
        </SubTree>
        <SubTree ID="StrawberryGetHandsFeatures">
            <output_port name="hand_features">Hand features</output_port>
        </SubTree>
        <SubTree ID="StrawberryGetHandsGesture">
            <input_port name="hands">Hands message</input_port>
            <output_port name="hands_gesture">Detected hands gesture name</output_port>
            <output_port name="hands_gestures_list">List of gestures detected with hands</output_port>
        </SubTree>
        <SubTree ID="StrawberryGetNewPeople">
            <output_port name="new_people">People that enter the scene</output_port>
        </SubTree>
        <SubTree ID="StrawberryGetPeople">
            <output_port name="header">Header info people in scene</output_port>
            <output_port name="people">People in scene</output_port>
        </SubTree>
        <SubTree ID="StrawberryGetPersonFaceEmotion">
            <output_port name="emotion_confidence">Confidence of emotion with more confidence</output_port>
            <output_port name="emotion_name">Name of emotion with more confidence</output_port>
            <output_port name="emotions">List of all emotions detected</output_port>
            <input_port name="person">Person to extract face emotion</input_port>
        </SubTree>
        <SubTree ID="StrawberryGetPersonFaceGender">
            <output_port name="is_male">True (1) if male, False (0) if female</output_port>
            <input_port name="person">Person message from where extract the gender</input_port>
        </SubTree>
        <SubTree ID="StrawberryGetPersonFaceHasMask">
            <output_port name="has_mask">True (1) if wearing a mask, False (0) if not wearing a mask</output_port>
            <input_port name="person">Person message who check if has mask</input_port>
        </SubTree>
        <SubTree ID="StrawberryGetPersonGesture">
            <output_port name="gesture_confidence">Confidence of gesture with more confidence</output_port>
            <output_port name="gesture_name">Name of gesture with more confidence</output_port>
            <output_port name="gestures">List of gestures detected</output_port>
            <input_port name="person">Person to extract gestures from</input_port>
        </SubTree>
        <SubTree ID="StrawberryInfoLog">
            <input_port name="string_1">First part of the console print text. Add whitespaces at the end if needed</input_port>
            <input_port name="string_2">Second part of the console print text.</input_port>
        </SubTree>
        <Action ID="StrawberryMonitorASR">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::ASRResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="StrawberryMonitorDialogue">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::DialogResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="StrawberryMonitorGesture">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::Gesture_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="StrawberryMonitorHandFeatures">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::HandFeatures_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="StrawberryMonitorHands">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::Hands_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="StrawberryMonitorPeople">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::People_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <Action ID="StrawberryMonitorWeather">
            <input_port default="0" name="consume_msgs" type="bool">Should messages be consumed?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Subscriber callback queue size</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::WeatherInfo_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="topic" type="std::string">Topic to subscribe</input_port>
        </Action>
        <SubTree ID="StrawberryOverrideDialogSessionEntity">
            <input_port name="entities">Serialized JSON with keys as entity values and values as coma-separated synonym strings</input_port>
            <input_port name="entity_name">Name of the Entity type to override entities. Must be one of those received from topic /strawberry/dialog_entity_types_list.</input_port>
            <input_port name="person_id">Unique ID of the person with white the event is associated</input_port>
            <output_port name="session_entities">List of entities available on this session</output_port>
        </SubTree>
        <Action ID="StrawberryPublishWeatherInfoByCoordinates">
            <input_port name="latitude" type="float">Auto-generated field from strawberry_ros_msgs::WeatherInfoByCoordinatesRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="longitude" type="float">Auto-generated field from strawberry_ros_msgs::WeatherInfoByCoordinatesRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::WeatherInfoByCoordinatesResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="StrawberryPublishWeatherInfoByPlacename">
            <input_port name="placename" type="std::string">Auto-generated field from strawberry_ros_msgs::WeatherInfoByPlacenameRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::WeatherInfoByPlacenameResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <SubTree ID="StrawberryRecordAudioAndWait">
            <input_port name="duration">Recording duration</input_port>
            <output_port name="file_name">Result audio file name</output_port>
            <input_port name="file_path">Folder where the audio will be saved</input_port>
            <output_port name="success">True if the recording was a success</output_port>
        </SubTree>
        <SubTree ID="StrawberryRemoveDialogEntity">
            <input_port default="0" name="auto_expansion">Enable / disable ML auto-expansion [1 / 0].</input_port>
            <input_port name="entity_name">Name of the Entity type. Must be one of those received from topic /strawberry/dialog_entity_types_list.</input_port>
            <input_port default="0" name="fuzzy_extraction">Enable / disable fuzzy extraction of entities [1 / 0]</input_port>
            <input_port default="KIND_MAP" name="kind">Kind of the Entity type. Must be one of: KIND_MAP, KIND_LIST, KIND_REGEXP. Defaults to KIND_MAP.</input_port>
        </SubTree>
        <SubTree ID="StrawberryRemoveDialogSessionEntity">
            <input_port name="entity_name">Name of the Entity type to remove entities. Must be one of those received from topic /strawberry/dialog_entity_types_list.</input_port>
            <input_port name="person_id">Unique ID of the person with white the event is associated</input_port>
            <output_port name="session_entities">List of entities available on this session</output_port>
        </SubTree>
        <Action ID="StrawberryResetConversation">
            <input_port name="person_id" type="unsigned int">Auto-generated field from strawberry_ros_msgs::ResetConversationRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::ResetConversationResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <SubTree ID="StrawberryResetDialogConversation">
            <input_port name="person_id">Person ID which conversation must be reset</input_port>
            <output_port name="result_msg">Dialog reset result text message</output_port>
            <output_port name="success">If dialog module was reset successfully</output_port>
        </SubTree>
        <SubTree ID="StrawberryResetPersonConversation">
            <input_port name="person">Person to reset conversation</input_port>
        </SubTree>
        <SubTree ID="StrawberrySetDialogEvent">
            <input_port name="event_name"/>
            <input_port name="parameters">JSON List of keys and values</input_port>
            <input_port name="person_id"/>
            <output_port name="result">DialogResult as JSON</output_port>
            <output_port name="success"/>
        </SubTree>
        <SubTree ID="StrawberrySetDialogTheme">
            <input_port name="agent">Name of agent for conversation</input_port>
        </SubTree>
        <Action ID="StrawberrySetDialogueAgent">
            <input_port name="selected_agent" type="std::string">Auto-generated field from strawberry_ros_msgs::SetAgentRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::SetAgentResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="StrawberrySetSpeechTarget">
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::SetSpeechTargetResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="target" type="int">Auto-generated field from strawberry_ros_msgs::SetSpeechTargetRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="StrawberrySetStartAudioRecording">
            <input_port name="file_path" type="std::string">Auto-generated field from strawberry_ros_msgs::StartAudioRecordingRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="file_prefix" type="std::string">Auto-generated field from strawberry_ros_msgs::StartAudioRecordingRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::StartAudioRecordingResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="StrawberrySetStartLearningFace">
            <input_port name="blocking" type="bool">Flag to wait for the training result</input_port>
            <input_port name="iterations" type="unsigned int">Number of iterations to train the face</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::FaceLearningResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="target_name" type="std::string">Name for the new trained face</input_port>
        </Action>
        <Action ID="StrawberrySetStartLearningFaceByTopic">
            <input_port name="img_topic_name" type="std::string">Compressed image topic name</input_port>
            <input_port name="iterations" type="unsigned int">Number of iterations to train the face</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::FaceLearningByTopicResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
            <input_port name="target_name" type="std::string">Name for the new trained face</input_port>
        </Action>
        <Action ID="StrawberrySetStopAudioRecording">
            <input_port name="file_name" type="std::string">Auto-generated field from strawberry_ros_msgs::StopAudioRecordingRequest_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::StopAudioRecordingResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <SubTree ID="StrawberryStartAudioRecording">
            <output_port name="file_name">Result audio file name</output_port>
            <input_port name="file_path">Folder where the audio file will be saved</input_port>
            <output_port name="success">True if the audio file recording started correctly</output_port>
        </SubTree>
        <SubTree ID="StrawberryStopAudioRecording">
            <input_port name="file_name">Name of the audio file recording to be stopped</input_port>
            <output_port name="success">True if it was stopped correctly</output_port>
        </SubTree>
        <SubTree ID="StrawberryTrainNewFace">
            <input_port default="1" name="blocking">True to call the trainging service and wait for the training result. False to call it and not wait</input_port>
            <input_port name="iterations">Number ot iterations to train the face</input_port>
            <output_port name="success">Result of training process if blocking was set to True. Otherwise, it will be always true if simply the service was called correclty</output_port>
            <input_port name="target_name">Name for the trained face</input_port>
        </SubTree>
        <SubTree ID="StrawberryTrainNewFaceByTopic">
            <input_port name="image_topic_name">Compressed image topic to use to train the face. It can be different than strawberry-ros-faces input image topics</input_port>
            <input_port default="0" name="iterations">Number of iterations to train the face. 0 to use the default value</input_port>
            <output_port name="success">Training result. True if trained successfully and false otherwise</output_port>
            <input_port name="target_name">Name for the trained face</input_port>
        </SubTree>
        <Action ID="StrawberryTriggerDialogueEvent">
            <input_port name="event_name" type="std::string">Name of the event to trigger</input_port>
            <input_port name="parameters" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized JSON with keys as parameter names and values as parameter values</input_port>
            <input_port name="person_id" type="unsigned int">Unique ID of the person with white the event is associated</input_port>
            <output_port name="serialized_output" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::TriggerDialogEventResponse_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="service" type="std::string">ROS service name</input_port>
        </Action>
        <Action ID="TextCleanupApiCallAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="sentence" type="std::string">user sentence</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonWakeUpWordFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::GetPersonWakeUpWordResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
        </Action>
        <Action ID="UnityProjectorCommandSetChatMessage">
            <input_port name="ipad_ids.data" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::UnityProjectorSetChatMessage_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port name="messages.data" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::UnityProjectorSetChatMessage_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="UnityProjectorCommandSetDraw">
            <input_port name="draw_image" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::UnityProjectorSetDraw_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="ipad_id" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::UnityProjectorSetDraw_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="UnityProjectorCommandSetMiniCam">
            <input_port name="activate_mini_cam" type="bool">Auto-generated field from haru_encouraging_mediator_msgs::UnityProjectorSetMiniCam_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="show_own_cam" type="bool">Auto-generated field from haru_encouraging_mediator_msgs::UnityProjectorSetMiniCam_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="UnityProjectorCommandSetProfiles">
            <input_port name="avatars" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Array with avatar image file path of each user registered</input_port>
            <input_port name="ipad_ids" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Array with iPad ID of each user registered</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
            <input_port name="user_names" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Array with the name of the users registered</input_port>
        </Action>
        <Action ID="UnityProjectorCommandSetStaticImage">
            <input_port name="activate_static_image" type="bool">Auto-generated field from haru_encouraging_mediator_msgs::UnityProjectorSetStaticImage_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="image_file" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::UnityProjectorSetStaticImage_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="UnityProjectorCommandSetVideoPlayer">
            <input_port name="activate_video_player" type="bool">Auto-generated field from haru_encouraging_mediator_msgs::UnityProjectorSetVideoPlayer_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
            <input_port name="video_file" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::UnityProjectorSetVideoPlayer_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="UnityProjectorCommandShowChat">
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port name="message_delay" type="float">Auto-generated field from haru_encouraging_mediator_msgs::UnityProjectorShowChat_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="show_chat" type="bool">Auto-generated field from haru_encouraging_mediator_msgs::UnityProjectorShowChat_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="UnityProjectorCommandShowDraw">
            <input_port name="ipad_id" type="std::string">Auto-generated field from haru_encouraging_mediator_msgs::UnityProjectorShowDraw_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="show_draw_canvas" type="bool">Auto-generated field from haru_encouraging_mediator_msgs::UnityProjectorShowDraw_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
        </Action>
        <Action ID="UnityProjectorConversationApp">
            <input_port name="activate_url" type="bool">Auto-generated field from strawberry_ros_msgs::UnityProjectorSetConversationApp_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="app_name" type="std::string">Auto-generated field from strawberry_ros_msgs::UnityProjectorSetConversationApp_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port default="0" name="latch" type="bool">Latch messages?</input_port>
            <input_port default="1" name="queue_size" type="unsigned int">Internal publisher queue size</input_port>
            <input_port name="topic" type="std::string">Topic to publish to</input_port>
            <input_port name="url" type="std::string">Auto-generated field from strawberry_ros_msgs::UnityProjectorSetConversationApp_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <SubTree ID="UnityProjectorGetVideoFinished">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <output_port default="unity_video_finished" name="video_finished">True if the video being played has finished, false otherwise</output_port>
        </SubTree>
        <SubTree ID="UnityProjectorHideChat"/>
        <SubTree ID="UnityProjectorHideDraw"/>
        <SubTree ID="UnityProjectorHideImage"/>
        <SubTree ID="UnityProjectorHideProfiles"/>
        <SubTree ID="UnityProjectorSetChatMessage">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port name="ipad_id">iPad ID sending the message</input_port>
            <input_port name="message">Message sent to show in the chat</input_port>
        </SubTree>
        <SubTree ID="UnityProjectorSetDraw">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port name="image">Full path of the image to show</input_port>
            <input_port name="ipad_id">ID of iPad that sent the image</input_port>
        </SubTree>
        <SubTree ID="UnityProjectorSetProfiles">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port name="avatars">Array with avatars images file path</input_port>
            <input_port name="ipad_ids">Array with iPad IDs</input_port>
            <input_port name="user_names">Array with user names</input_port>
        </SubTree>
        <SubTree ID="UnityProjectorShowChat">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port default="15.0" name="time_between_msgs">Time to waiting before showing a new message [seconds]</input_port>
        </SubTree>
        <SubTree ID="UnityProjectorShowDraw">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port name="ipad_id">iPad ID of draw to show in the projector</input_port>
        </SubTree>
        <SubTree ID="UnityProjectorShowImage">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port name="image_file">Name of the image to show</input_port>
        </SubTree>
        <SubTree ID="UnityProjectorShowProfiles"/>
        <SubTree ID="UnityProjectorShowVideo">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port name="video_file">Name of the video file to play</input_port>
        </SubTree>
        <SubTree ID="UnityProjectorShowVideoAndWait">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port name="video_file">Name of the video to play</input_port>
        </SubTree>
        <SubTree ID="UnityProjectorStopVideo"/>
        <SubTree ID="UnityProjectorTeleconferenceMiniCamOFF"/>
        <SubTree ID="UnityProjectorTeleconferenceMiniCamON">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port default="false" name="own_cam">Image to show in minature window. False for the camera on the other side, true for your camera</input_port>
        </SubTree>
        <SubTree ID="UnityProjectorTeleconferenceOFF"/>
        <SubTree ID="UnityProjectorTeleconferenceON"/>
        <SubTree ID="WaitForHaruStartPlayingAudio">
            <input_port default="2000" name="timeout_ms">Timeout in milliseconds to exit and return False</input_port>
        </SubTree>
        <SubTree ID="WaitForPersonToStopTalking">
            <input_port name="checking_time">required silence time S</input_port>
            <input_port name="mode">detection mode</input_port>
            <output_port name="speaking">software output</output_port>
            <input_port name="turn_max_time">max turn time</input_port>
        </SubTree>
        <Action ID="WaitSpeakingStartsAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="mics_id" type="int">Auto-generated field from strawberry_ros_msgs::WaitSpeakingStartsGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::WaitSpeakingStartsFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::WaitSpeakingStartsResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
            <input_port name="timeout" type="unsigned int">Auto-generated field from strawberry_ros_msgs::WaitSpeakingStartsGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
        </Action>
        <Action ID="WaitSpeakingStopsAction">
            <input_port name="action" type="std::string">Actionlib action server name</input_port>
            <input_port name="hard_timeout" type="unsigned int">Auto-generated field from strawberry_ros_msgs::WaitSpeakingStopsGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <input_port name="mics_id" type="int">Auto-generated field from strawberry_ros_msgs::WaitSpeakingStopsGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="serialized_feedback" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::WaitSpeakingStopsFeedback_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <output_port name="serialized_result" type="nlohmann::basic_json&lt;std::map, std::vector, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, bool, long, unsigned long, double, std::allocator, nlohmann::adl_serializer&gt;">Serialized ROS message [strawberry_ros_msgs::WaitSpeakingStopsResult_&lt;std::allocator&lt;void&gt; &gt;]</output_port>
            <input_port name="soft_timeout" type="unsigned int">Auto-generated field from strawberry_ros_msgs::WaitSpeakingStopsGoal_&lt;std::allocator&lt;void&gt; &gt;</input_port>
            <output_port name="state" type="actionlib::SimpleClientGoalState">Actionlib reported state</output_port>
        </Action>
        <SubTree ID="WaitWhileSpeech">
            <input_port default="false" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
            <input_port default="-1" name="mics_id">ID of mics to check for speech. -1 for all available mics</input_port>
            <input_port default="false" name="physical_ack">Do physical acknowledge of hearing the conversation (lookAt and animation)</input_port>
            <input_port default="407;408" name="physical_ack_routine">Single routine to execute in physical acknowledge</input_port>
            <input_port default="300000" name="start_speaking_timeout">Time to wait for a conversation to start [milliseconds]</input_port>
            <input_port default="4000" name="stop_speaking_internal_timeout">Time of &quot;silence&quot; between senteces to know the conversation has finished [milliseconds]</input_port>
            <input_port default="300000" name="stop_speaking_timeout">Time to wait for a conversation to finish [milliseconds]</input_port>
            <input_port default="false" name="verbal_ack">Do verbal acknowledge of hearing the conversation (dialogue)</input_port>
        </SubTree>
        <Action ID="WarnLog">
            <input_port name="message" type="std::string">Message to log</input_port>
        </Action>
        <SubTree ID="WhileHaruAudioIsPlaying"/>
        <SubTree ID="WhileHaruLCDIsPlaying"/>
        <SubTree ID="WhileHaruProjectorIsPlaying"/>
        <SubTree ID="WhileHaruRoutineIsPlaying"/>
        <SubTree ID="WhileHaruTTSIsPlaying"/>
        <SubTree ID="waitForAnyAsr"/>
    </TreeNodesModel>
    <!-- ////////// -->
</root>

